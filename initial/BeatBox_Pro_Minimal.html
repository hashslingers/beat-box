<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <title>BEAT-BOX</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@100;200;300;400;500;600&display=swap');
    
    :root {
      /* TE Cream Theme */
      --bg: #F5F3EF;
      --surface: #FEFEFE;
      --border: #E8E6E2;
      --text: #1A1918;
      --text-muted: #6B6966;
      --text-dim: #B8B5B0;
      --accent: #FF6B00;
      --grid-gap: 1px;
      --transition: cubic-bezier(0.23, 1, 0.32, 1);

      /* LCD Display */
      --lcd-bg: #C5CDB8;
      --lcd-text: #2D3328;

      /* Fretboard Colors */
      --color-root: #FF6B00;
      --color-3: #00D4AA;
      --color-5: #0099AA;
      --color-7: #1A5070;
      --color-passing: #C0BCB8;

      /* Fretboard */
      --fretboard-bg: linear-gradient(180deg, #3D3530 0%, #2A2522 100%);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      font-family: 'JetBrains Mono', monospace;
      background: var(--bg);
      color: var(--text);
      overflow-x: hidden;
      user-select: none;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      touch-action: manipulation;
      scroll-behavior: auto;
    }

    .container {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      max-width: 1200px;
      margin: 0 auto;
    }

    /* Header */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      padding: 40px 40px 20px;
      border-bottom: 1px solid var(--border);
      animation: fadeIn 0.6s var(--transition);
    }

    .logo {
      font-size: 14px;
      font-weight: 200;
      letter-spacing: 0.3em;
      color: var(--text);
    }

    .status {
      font-size: 10px;
      color: var(--text-dim);
      letter-spacing: 0.1em;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status::before {
      content: '';
      width: 6px;
      height: 6px;
      background: var(--text-dim);
      display: inline-block;
      animation: pulse 2s ease-in-out infinite;
    }

    .status.playing::before {
      background: var(--text);
      animation: pulse 0.5s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }

    /* Navigation Tabs */
    .nav-tabs {
      display: flex;
      gap: 0;
      padding: 0 40px;
      border-bottom: 1px solid var(--border);
      animation: fadeIn 0.6s var(--transition) 0.05s both;
    }

    .nav-tab {
      padding: 16px 24px;
      font-size: 11px;
      font-weight: 500;
      letter-spacing: 0.2em;
      color: var(--text-muted);
      background: transparent;
      border: none;
      border-bottom: 2px solid transparent;
      cursor: pointer;
      transition: all 0.2s var(--transition);
      margin-bottom: -1px;
    }

    .nav-tab:hover {
      color: var(--text);
    }

    .nav-tab.active {
      color: var(--text);
      border-bottom-color: var(--accent);
    }

    /* View Containers */
    .view {
      display: none;
    }

    .view.active {
      display: block;
    }

    /* Main Tempo Display with Volume Controls */
    .tempo-section {
      padding: 60px 40px;
      border-bottom: 1px solid var(--border);
      animation: fadeIn 0.8s var(--transition) 0.1s both;
      position: relative;
    }
    
    .tempo-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 60px;
    }
    
    .vertical-volume {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }
    
    .volume-value {
      font-size: 14px;
      font-weight: 200;
      color: var(--text-muted);
      min-width: 35px;
      text-align: center;
    }
    
    .volume-track {
      width: 3px;
      height: 140px;
      background: var(--border);
      position: relative;
      border-radius: 2px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .volume-track:hover {
      background: var(--text-dim);
    }

    .volume-fill {
      position: absolute;
      bottom: 0;
      width: 100%;
      background: linear-gradient(180deg, var(--text), var(--text-muted));
      border-radius: 2px;
      transition: height 0.3s;
      pointer-events: none;
    }

    .volume-thumb {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      width: 12px;
      height: 12px;
      background: var(--text);
      border-radius: 2px;
      cursor: pointer;
      transition: all 0.2s;
      pointer-events: none;
    }

    .volume-track:hover .volume-thumb {
      width: 16px;
      height: 16px;
    }

    .volume-label {
      font-size: 10px;
      font-weight: 500;
      letter-spacing: 0.2em;
      color: var(--text-muted);
      text-transform: uppercase;
      writing-mode: vertical-rl;
      text-orientation: mixed;
    }
    
    .tempo-display {
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      padding: 20px;
      border-radius: 4px;
      user-select: none;
      outline: none;
      -webkit-tap-highlight-color: transparent;
    }
    
    .tempo-display:hover {
      background: rgba(0,0,0,0.02);
    }
    
    .tempo-display:active {
      transform: scale(0.98);
    }

    .tempo-value {
      font-size: clamp(80px, 12vw, 140px);
      font-weight: 100;
      line-height: 1;
      color: var(--text);
      position: relative;
      transition: transform 0.3s var(--transition);
    }

    .tempo-label {
      margin-top: 16px;
      font-size: 11px;
      font-weight: 500;
      letter-spacing: 0.3em;
      color: var(--text-muted);
      text-transform: uppercase;
    }
    
    .tap-hint {
      margin-top: 8px;
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      letter-spacing: 0.15em;
      text-transform: uppercase;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .tempo-display:hover .tap-hint {
      opacity: 1;
    }

    /* Play/Stop Button */
    .play-button {
      position: absolute;
      top: 50%;
      right: 40px;
      transform: translateY(-50%);
      width: 60px;
      height: 60px;
      background: transparent;
      border: 1px solid var(--border);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s var(--transition);
    }

    .play-button:hover {
      border-color: var(--text-muted);
      background: rgba(0,0,0,0.02);
    }

    .play-button.playing {
      background: var(--text);
    }

    .play-icon {
      width: 0;
      height: 0;
      border-left: 16px solid var(--text);
      border-top: 10px solid transparent;
      border-bottom: 10px solid transparent;
      margin-left: 4px;
      transition: all 0.3s var(--transition);
    }

    .play-button.playing .play-icon {
      width: 16px;
      height: 16px;
      border: none;
      background: var(--bg);
      margin-left: 0;
    }

    /* Sequencer Grid */
    .sequencer {
      padding: 40px;
      animation: fadeIn 0.8s var(--transition) 0.2s both;
    }
    
    .step-numbers {
      display: grid;
      grid-template-columns: 80px 1fr;
      gap: 20px;
      align-items: center;
      margin-bottom: 16px;
    }
    
    .number-spacer {
      width: 80px;
    }
    
    .numbers-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 6px;
      padding: 12px;
    }
    
    .step-number {
      text-align: center;
      font-size: 10px;
      font-weight: 500;
      color: var(--text-muted);
      letter-spacing: 0.1em;
      padding: 4px 0;
    }

    .track {
      display: grid;
      grid-template-columns: 80px 1fr;
      gap: 20px;
      align-items: center;
      margin-bottom: 24px;
      position: relative;
    }

    .track::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 3px;
      background: linear-gradient(180deg, transparent, var(--border), transparent);
    }
    
    .track[data-track="kick"]::before {
      background: linear-gradient(180deg, transparent, #ff4444, transparent);
    }
    
    .track[data-track="snare"]::before {
      background: linear-gradient(180deg, transparent, #ffaa00, transparent);
    }
    
    .track[data-track="hihat"]::before {
      background: linear-gradient(180deg, transparent, #00aaff, transparent);
    }

    .track-label {
      font-size: 11px;
      font-weight: 500;
      letter-spacing: 0.1em;
      color: var(--text-muted);
      text-align: right;
      text-transform: uppercase;
      cursor: pointer;
      transition: color 0.2s;
    }

    .track-label:hover {
      color: var(--text);
    }

    .track-label.muted {
      color: var(--text-dim);
      text-decoration: line-through;
    }

    .steps {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 6px;
      padding: 12px;
      background: var(--lcd-bg);
      border: 1px solid var(--border);
      border-radius: 4px;
    }

    .step {
      aspect-ratio: 2/1;
      background: rgba(45, 51, 40, 0.2);
      border: 2px solid rgba(45, 51, 40, 0.3);
      position: relative;
      cursor: pointer;
      transition: all 0.2s ease-out;
      overflow: hidden;
      box-shadow:
        inset 0 2px 4px rgba(0,0,0,0.1),
        0 1px 3px rgba(0,0,0,0.05);
      border-radius: 2px;
    }

    .step::before {
      content: '';
      position: absolute;
      inset: 0;
      background: var(--lcd-text);
      transform: scale(0);
      transition: transform 0.3s var(--transition);
    }

    .step:hover {
      border-color: var(--lcd-text);
      background: rgba(45, 51, 40, 0.3);
      transform: translateY(-2px);
      box-shadow:
        inset 0 2px 4px rgba(0,0,0,0.1),
        0 4px 12px rgba(0,0,0,0.1);
    }

    .step.active::before {
      transform: scale(1);
    }

    .step.playing {
      transform: scaleY(1.15);
      border-color: var(--lcd-text);
      z-index: 1;
      box-shadow:
        inset 0 1px 2px rgba(0,0,0,0.2),
        0 0 15px rgba(45, 51, 40, 0.4),
        0 0 5px rgba(45, 51, 40, 0.6);
    }

    .step.playing.active::before {
      animation: flash 0.2s ease-out;
    }

    @keyframes flash {
      0% { opacity: 1; }
      50% { opacity: 0.6; }
      100% { opacity: 1; }
    }

    /* Control Grid */
    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1px;
      background: var(--border);
      padding: 1px;
      margin: 40px;
      animation: fadeIn 0.8s var(--transition) 0.3s both;
    }

    .control {
      background: var(--bg);
      padding: 30px 20px;
      text-align: center;
      cursor: pointer;
      transition: background 0.3s;
    }

    .control:hover {
      background: rgba(0,0,0,0.02);
    }

    .control-value {
      font-size: 32px;
      font-weight: 100;
      color: var(--text);
      margin-bottom: 8px;
      transition: transform 0.2s;
    }

    .control:hover .control-value {
      transform: translateY(-2px);
    }

    .control-label {
      font-size: 10px;
      font-weight: 500;
      letter-spacing: 0.2em;
      color: var(--text-muted);
      text-transform: uppercase;
    }

    /* Pattern Presets */
    .presets {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 1px;
      background: var(--border);
      padding: 1px;
      margin: 0 40px 40px;
      animation: fadeIn 0.8s var(--transition) 0.4s both;
    }

    .preset-btn {
      background: var(--bg);
      border: none;
      color: var(--text-muted);
      padding: 20px;
      font-family: inherit;
      font-size: 11px;
      font-weight: 500;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.3s var(--transition);
    }

    .preset-btn:hover {
      background: var(--text);
      color: var(--bg);
    }

    /* Advanced Section */
    .advanced {
      margin-top: auto;
      padding: 40px;
      border-top: 1px solid var(--border);
      animation: fadeIn 0.8s var(--transition) 0.5s both;
    }

    .advanced-toggle {
      font-size: 11px;
      font-weight: 500;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: var(--text-muted);
      cursor: pointer;
      display: inline-block;
      transition: color 0.3s;
    }

    .advanced-toggle:hover {
      color: var(--text-muted);
    }

    .advanced-toggle.open {
      color: var(--text-muted);
    }

    .advanced-content {
      display: none;
      margin-top: 30px;
      gap: 30px;
    }

    .advanced-content.show {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      animation: fadeIn 0.4s var(--transition);
    }

    /* Sliders */
    .slider-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .slider-label {
      font-size: 11px;
      font-weight: 500;
      letter-spacing: 0.1em;
      color: var(--text-muted);
      text-transform: uppercase;
    }

    .slider {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 1px;
      background: var(--border);
      outline: none;
      transition: background 0.3s;
    }

    .slider:hover {
      background: var(--text-dim);
    }

    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 10px;
      height: 10px;
      background: var(--text);
      cursor: pointer;
      transition: transform 0.2s;
    }

    .slider::-webkit-slider-thumb:hover {
      transform: scale(1.5);
    }

    .slider::-moz-range-thumb {
      width: 10px;
      height: 10px;
      background: var(--text);
      cursor: pointer;
      border: none;
      transition: transform 0.2s;
    }

    .slider::-moz-range-thumb:hover {
      transform: scale(1.5);
    }

    .slider-value {
      font-size: 14px;
      font-weight: 200;
      color: var(--text);
      margin-top: 4px;
    }

    /* Action Buttons */
    .actions {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .action-btn {
      flex: 1;
      min-width: 100px;
      padding: 12px 20px;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-muted);
      font-family: inherit;
      font-size: 11px;
      font-weight: 500;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.3s var(--transition);
    }

    .action-btn:hover {
      color: var(--text);
      border-color: var(--text-muted);
      background: rgba(0,0,0,0.02);
    }

    /* Select */
    .select {
      width: 100%;
      padding: 12px;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text);
      font-family: inherit;
      font-size: 14px;
      font-weight: 200;
      cursor: pointer;
      transition: border-color 0.3s;
      outline: none;
    }

    .select:hover {
      border-color: var(--text-dim);
    }

    .select:focus {
      border-color: var(--text-muted);
    }

    /* Piano Keyboard */
    .piano-section {
      grid-column: 1 / -1; /* Span all columns */
    }

    .piano-container {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .piano-keyboard {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      height: 160px;
      position: relative;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 20px;
      overflow-x: auto; /* Allow horizontal scroll on very small screens */
      overflow-y: visible;
    }

    .piano-key {
      position: relative;
      cursor: pointer;
      transition: all 0.1s ease;
      user-select: none;
    }

    .piano-key.white {
      width: 28px;
      height: 110px;
      background: linear-gradient(180deg, #fff 0%, #e0e0e0 100%);
      border: 1px solid var(--text);
      border-radius: 0 0 3px 3px;
      box-shadow: inset 0 -3px 5px rgba(0,0,0,0.1);
      margin-right: -1px;
    }

    .piano-key.white:hover {
      background: linear-gradient(180deg, #f0f0f0 0%, #d0d0d0 100%);
    }

    .piano-key.white:active,
    .piano-key.white.active {
      background: linear-gradient(180deg, #c0c0c0 0%, #a0a0a0 100%);
      transform: translateY(2px);
      box-shadow: inset 0 3px 5px rgba(0,0,0,0.3);
    }

    .piano-key.black {
      width: 18px;
      height: 70px;
      background: linear-gradient(180deg, #000 0%, #1a1a1a 100%);
      border: 1px solid #000;
      border-radius: 0 0 2px 2px;
      position: absolute;
      z-index: 2;
      box-shadow:
        inset 0 -2px 3px rgba(255,255,255,0.1),
        0 2px 4px rgba(0,0,0,0.5);
    }

    .piano-key.black:hover {
      background: linear-gradient(180deg, #1a1a1a 0%, #2a2a2a 100%);
    }

    .piano-key.black:active,
    .piano-key.black.active {
      background: linear-gradient(180deg, #333 0%, #444 100%);
      transform: translateY(2px);
    }

    .piano-label {
      position: absolute;
      bottom: 6px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 8px;
      font-weight: 500;
      color: var(--text-dim);
      pointer-events: none;
      text-align: center;
      white-space: nowrap;
    }

    .piano-key.white .piano-label {
      color: var(--text-muted);
    }

    .piano-key.black .piano-label {
      display: none; /* Hide black key labels for cleaner look */
    }

    .piano-key.active .piano-label {
      color: var(--text);
      font-weight: 700;
    }

    .piano-key.black.active .piano-label {
      color: #fff;
    }

    /* Highlight middle C */
    .piano-key.white[data-note="C3"] .piano-label {
      color: var(--surface);
      background: var(--text);
      padding: 2px 4px;
      border-radius: 2px;
      font-weight: 700;
      font-size: 9px;
      bottom: 8px;
    }

    .piano-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 4px;
    }

    .piano-active-notes {
      font-size: 11px;
      font-weight: 500;
      color: var(--text-muted);
      letter-spacing: 0.1em;
    }

    .piano-clear {
      font-size: 10px;
      font-weight: 500;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      cursor: pointer;
      transition: color 0.2s;
    }

    .piano-clear:hover {
      color: var(--text);
    }

    /* Performance Mode */
    body.performance .step {
      border-width: 2px;
    }

    body.performance .steps {
      gap: 3px;
    }

    body.performance .step.playing {
      box-shadow: 0 0 20px rgba(45, 51, 40, 0.4);
      transform: scaleY(1.2);
    }

    body.performance .tempo-value {
      animation: glow 2s ease-in-out infinite;
    }

    @keyframes glow {
      0%, 100% { text-shadow: none; }
      50% { text-shadow: 0 0 30px rgba(0,0,0,0.1); }
    }

    /* Animations */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Mobile Optimization */
    @media (max-width: 768px) {
      .header {
        padding: 20px;
      }
      
      .tempo-section {
        padding: 40px 20px;
      }
      
      .tempo-container {
        gap: 30px;
      }
      
      .vertical-volume {
        gap: 8px;
      }
      
      .volume-track {
        height: 100px;
      }
      
      .tempo-value {
        font-size: 70px;
      }
      
      .play-button {
        position: static;
        transform: none;
        margin: 30px auto 0;
      }
      
      .sequencer {
        padding: 20px;
      }
      
      .track {
        grid-template-columns: 60px 1fr;
        gap: 15px;
      }
      
      /* Enhanced step touch targets for mobile */
      .step {
        min-width: 44px;
        min-height: 44px;
        border-radius: 3px;
        border-width: 1px;
      }
      
      /* Improved grid spacing for easier touch */
      .steps {
        gap: 8px;
        padding: 16px;
        border-radius: 6px;
      }
      
      /* Better preset button spacing */
      .preset-btn {
        padding: 24px 16px;
        font-size: 10px;
        letter-spacing: 0.05em;
      }
      
      /* Optimized volume controls for touch */
      .volume-track {
        width: 6px;
        height: 80px;
      }
      
      .volume-thumb {
        width: 16px;
        height: 16px;
        border-radius: 3px;
      }
      
      .controls {
        margin: 20px;
        grid-template-columns: repeat(2, 1fr);
      }
      
      .presets {
        margin: 0 20px 20px;
        grid-template-columns: repeat(2, 1fr);
      }
      
      .advanced {
        padding: 20px;
      }
      
      .advanced-content {
        grid-template-columns: 1fr;
      }
    }

    /* Landscape Mobile - Optimized for Touch */
    @media (max-width: 768px) and (orientation: landscape) {
      .tempo-section {
        padding: 15px;
      }
      
      .tempo-container {
        gap: 20px;
      }
      
      .tempo-value {
        font-size: 50px;
      }
      
      .volume-track {
        height: 60px;
      }
      
      .sequencer {
        padding: 10px;
      }
      
      .track {
        margin-bottom: 12px;
      }
      
      .steps {
        gap: 6px;
        padding: 12px;
      }
      
      .step {
        min-height: 36px;
      }
      
      .presets {
        margin: 0 10px 10px;
      }
      
      .preset-btn {
        padding: 16px 12px;
        font-size: 9px;
      }
    }

    /* Enhanced Touch Feedback & Performance */
    @media (hover: none) {
      /* Reduce animations for better mobile performance */
      * {
        transition-duration: 0.1s !important;
      }
      
      .step {
        /* Better touch targets */
        padding: 2px;
        transition: all 0.05s ease-out;
      }
      
      .step:active {
        transform: scale(0.92);
        background: rgba(45, 51, 40, 0.5);
        border-color: var(--lcd-text);
      }

      .step.playing {
        /* Optimized playing animation for mobile */
        transform: scaleY(1.1);
        box-shadow: 0 0 8px rgba(45, 51, 40, 0.5);
      }

      .preset-btn:active,
      .action-btn:active {
        transform: scale(0.96);
        background: rgba(0,0,0,0.05);
      }

      .tempo-display:active {
        transform: scale(0.98);
      }

      .volume-track:active {
        background: var(--text-muted);
      }

      /* Disable complex animations on mobile for performance */
      .tempo-value {
        animation: none !important;
      }

      /* Simpler glow effect for mobile */
      body.performance .step.playing {
        box-shadow: 0 0 10px rgba(45, 51, 40, 0.4);
        transform: scaleY(1.15);
      }
    }

    /* ========== FRETBOARD VIEW STYLES ========== */

    /* Fretboard Device Container */
    .fretboard-device {
      max-width: 900px;
      margin: 0 auto;
      background: var(--surface);
      border-radius: 12px;
      box-shadow:
        0 1px 2px rgba(0,0,0,0.04),
        0 4px 8px rgba(0,0,0,0.04),
        0 12px 24px rgba(0,0,0,0.06);
      overflow: hidden;
    }

    /* Fretboard Header */
    .fretboard-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
    }

    .fretboard-logo {
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .fretboard-logo span {
      color: var(--accent);
    }

    .mode-badge {
      background: var(--accent);
      color: white;
      font-size: 10px;
      font-weight: 600;
      padding: 4px 10px;
      border-radius: 4px;
      letter-spacing: 0.5px;
    }

    /* Fretboard Controls */
    .fretboard-controls {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 12px;
      padding: 16px 20px;
      background: var(--border);
      border-bottom: 1px solid var(--text-dim);
    }

    .fb-control-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .fb-control-label {
      font-size: 9px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-muted);
    }

    .fb-lcd-display {
      background: var(--lcd-bg);
      color: var(--lcd-text);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 600;
      text-align: center;
      border: 1px solid #A8B09C;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
    }

    .fb-button-row {
      display: flex;
      gap: 4px;
    }

    .fb-btn {
      flex: 1;
      background: var(--surface);
      border: 1px solid var(--text-dim);
      border-radius: 4px;
      padding: 8px 6px;
      font-family: inherit;
      font-size: 10px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.1s ease;
    }

    .fb-btn:hover {
      background: var(--border);
    }

    .fb-btn.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    /* Legend */
    .fb-legend {
      display: flex;
      gap: 16px;
      padding: 12px 20px;
      border-bottom: 1px solid var(--border);
      flex-wrap: wrap;
    }

    .fb-legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 10px;
      color: var(--text-muted);
    }

    .fb-legend-dot {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 700;
      color: white;
    }

    .fb-legend-dot.root {
      background: var(--color-root);
      width: 24px;
      height: 24px;
      font-size: 12px;
    }
    .fb-legend-dot.chord-3 { background: var(--color-3); color: var(--text); }
    .fb-legend-dot.chord-5 { background: var(--color-5); }
    .fb-legend-dot.chord-7 { background: var(--color-7); }
    .fb-legend-dot.passing { background: var(--color-passing); color: var(--text-muted); }

    /* Fretboard Container */
    .fretboard-container {
      padding: 20px;
      overflow-x: auto;
    }

    .fretboard {
      display: flex;
      flex-direction: column;
      min-width: 800px;
      background: var(--fretboard-bg);
      border-radius: 8px;
      padding: 16px 12px;
      position: relative;
    }

    /* Fret Numbers */
    .fret-numbers {
      display: grid;
      grid-template-columns: 40px repeat(15, 1fr);
      gap: 2px;
      margin-bottom: 8px;
    }

    .fret-num {
      text-align: center;
      font-size: 9px;
      font-weight: 600;
      color: var(--text-dim);
    }

    .fret-num.marker {
      color: var(--accent);
    }

    /* String Row */
    .string-row {
      display: grid;
      grid-template-columns: 40px repeat(15, 1fr);
      gap: 2px;
      align-items: center;
      height: 44px;
      position: relative;
    }

    .string-row::after {
      content: '';
      position: absolute;
      left: 44px;
      right: 4px;
      top: 50%;
      height: 2px;
      background: linear-gradient(90deg, #B8A89A 0%, #8B7D70 100%);
      border-radius: 1px;
      z-index: 0;
    }

    .string-row:nth-child(2)::after { height: 2.5px; }
    .string-row:nth-child(3)::after { height: 3px; }
    .string-row:nth-child(4)::after { height: 3.5px; }
    .string-row:nth-child(5)::after { height: 4px; }
    .string-row:nth-child(6)::after { height: 4.5px; }

    .string-label {
      font-size: 11px;
      font-weight: 600;
      color: var(--bg);
      text-align: center;
    }

    .fret {
      position: relative;
      z-index: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
    }

    .fret::before {
      content: '';
      position: absolute;
      right: 0;
      top: 4px;
      bottom: 4px;
      width: 2px;
      background: linear-gradient(180deg, #C0B0A0 0%, #A09080 50%, #C0B0A0 100%);
      border-radius: 1px;
    }

    .fret:first-of-type::before {
      width: 4px;
      background: #E8DDD0;
    }

    .note {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 13px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.15s ease;
      position: relative;
      z-index: 2;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    .note:hover {
      transform: scale(1.15);
    }

    /* Note Color Classes - A+B Scheme */
    .note.root {
      width: 38px;
      height: 38px;
      font-size: 15px;
      background: var(--color-root);
      color: white;
      box-shadow: 0 3px 10px rgba(255,107,0,0.6);
    }

    .note.degree-3 {
      background: var(--color-3);
      color: var(--text);
      box-shadow: 0 2px 6px rgba(0,212,170,0.4);
    }

    .note.degree-5 {
      background: var(--color-5);
      color: white;
      box-shadow: 0 2px 6px rgba(0,153,170,0.4);
    }

    .note.degree-7 {
      background: var(--color-7);
      color: white;
      box-shadow: 0 2px 6px rgba(26,80,112,0.4);
    }

    /* Passing tones: 2, 4, 6 */
    .note.degree-2,
    .note.degree-4,
    .note.degree-6 {
      background: var(--color-passing);
      color: var(--text-muted);
    }

    /* Fret Markers (inlays) */
    .fret-markers {
      display: grid;
      grid-template-columns: 40px repeat(15, 1fr);
      gap: 2px;
      margin-top: 8px;
    }

    .marker-cell {
      display: flex;
      justify-content: center;
    }

    .inlay {
      width: 8px;
      height: 8px;
      background: var(--bg);
      border-radius: 50%;
      opacity: 0.6;
    }

    .inlay.double {
      width: 16px;
      display: flex;
      gap: 6px;
    }

    .inlay.double::before,
    .inlay.double::after {
      content: '';
      width: 6px;
      height: 6px;
      background: var(--bg);
      border-radius: 50%;
    }

    /* Mode Info Panel */
    .mode-info {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 4px;
      padding: 16px 20px;
      background: var(--border);
    }

    .mode-card {
      background: var(--surface);
      border: 1px solid var(--text-dim);
      border-radius: 6px;
      padding: 10px 6px;
      text-align: center;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .mode-card:hover {
      border-color: var(--accent);
    }

    .mode-card.active {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    .mode-card .note-name {
      font-size: 18px;
      font-weight: 700;
      display: block;
    }

    .mode-card .name {
      font-size: 7px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      opacity: 0.7;
      margin-top: 2px;
    }

    .mode-card.active .name {
      opacity: 1;
    }

    /* Scale Pattern Display */
    .fb-pattern-display {
      padding: 16px 20px;
      border-top: 1px solid var(--border);
    }

    .fb-pattern-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .fb-pattern-row:last-child {
      margin-bottom: 0;
    }

    .fb-pattern-label {
      font-size: 9px;
      font-weight: 600;
      text-transform: uppercase;
      color: var(--text-muted);
      width: 60px;
    }

    .intervals {
      display: flex;
      gap: 4px;
    }

    .interval {
      width: 28px;
      height: 28px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: 600;
      background: var(--border);
      color: var(--text-muted);
    }

    .interval.whole { background: var(--text); color: var(--surface); }
    .interval.half { background: var(--accent); color: white; }

    /* Pattern note colors */
    .interval.root-note { background: var(--color-root); color: white; }
    .interval.chord-3 { background: var(--color-3); color: var(--text); }
    .interval.chord-5 { background: var(--color-5); color: white; }
    .interval.chord-7 { background: var(--color-7); color: white; }
    .interval.passing { background: var(--color-passing); color: white; }

    /* Fretboard Footer */
    .fretboard-footer {
      display: flex;
      justify-content: space-between;
      padding: 12px 20px;
      border-top: 1px solid var(--border);
      font-size: 9px;
      color: var(--text-muted);
    }

    /* Rotate hint for portrait mobile */
    .rotate-hint {
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
      padding: 60px 20px;
      text-align: center;
    }

    .rotate-icon {
      font-size: 48px;
      animation: rotate-hint 2s ease-in-out infinite;
    }

    @keyframes rotate-hint {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(90deg); }
    }

    .rotate-text {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-muted);
    }

    /* FRETBOARD Mobile Landscape */
    @media (max-width: 900px) and (orientation: landscape) {
      .fretboard-device {
        border-radius: 8px;
      }

      .fretboard-header {
        padding: 8px 12px;
      }

      .fretboard-controls {
        padding: 10px 12px;
        gap: 8px;
      }

      .fb-legend {
        padding: 8px 12px;
        gap: 10px;
      }

      .fretboard-container {
        padding: 12px;
      }

      .fretboard {
        min-width: 700px;
        padding: 12px 10px;
      }

      .mode-info {
        padding: 10px 12px;
        gap: 3px;
      }

      .mode-card {
        padding: 6px 4px;
      }

      .mode-card .note-name {
        font-size: 14px;
      }

      .mode-card .name {
        font-size: 6px;
      }

      .fb-pattern-display {
        padding: 10px 12px;
      }

      .fretboard-footer {
        padding: 8px 12px;
      }
    }

    /* FRETBOARD Mobile Portrait - show rotate hint */
    @media (max-width: 768px) and (orientation: portrait) {
      .fretboard-controls {
        grid-template-columns: 1fr 1fr;
      }

      .fretboard-container {
        display: none;
      }

      .rotate-hint {
        display: flex;
      }

      .mode-info {
        grid-template-columns: repeat(4, 1fr);
      }

      .fb-pattern-display {
        overflow-x: auto;
      }
    }

    /* ========== END FRETBOARD STYLES ========== */

    /* Loading State */
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      animation: fadeOut 0.5s 0.5s forwards;
    }

    @keyframes fadeOut {
      to {
        opacity: 0;
        pointer-events: none;
      }
    }

    .loading-text {
      font-size: 12px;
      font-weight: 200;
      letter-spacing: 0.3em;
      color: var(--text-muted);
      animation: pulse 1s ease-in-out infinite;
    }

    /* Visualization Section */
    .visualization-section {
      padding: 40px;
      border-bottom: 1px solid var(--border);
      animation: fadeIn 0.8s var(--transition) 0.15s both;
    }

    .viz-container {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 60px;
      flex-wrap: wrap;
    }

    /* Circular Beat Visualizer */
    .beat-circle-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      position: relative;
    }

    .beat-circle {
      width: 200px;
      height: 200px;
      filter: drop-shadow(0 0 1px rgba(255,255,255,0.1));
      transition: filter 0.1s ease-out;
    }

    .beat-circle-container.flash .beat-circle {
      filter: drop-shadow(0 0 20px rgba(255,68,68,0.6));
    }

    .beat-segment {
      fill: #1a1a1a;
      stroke: #333;
      stroke-width: 1.5;
      transition: fill 0.08s ease-out;
      cursor: default;
    }

    .beat-segment.active {
      fill: #ffffff;
    }

    .beat-segment.beat-one {
      stroke: #ff4444;
      stroke-width: 2.5;
    }

    .beat-playhead {
      stroke: #ffffff;
      stroke-width: 2;
      stroke-linecap: round;
      transform-origin: 100px 100px;
      transition: transform 0.05s linear;
      opacity: 0.8;
    }

    .beat-center-text {
      fill: #666;
      font-family: 'JetBrains Mono', monospace;
      font-size: 24px;
      font-weight: 200;
      text-anchor: middle;
      dominant-baseline: middle;
      transition: fill 0.1s;
    }

    .beat-center-text.active {
      fill: #ffffff;
      font-weight: 400;
    }

    .beat-label {
      font-size: 10px;
      font-weight: 500;
      letter-spacing: 0.2em;
      color: #999;
      text-transform: uppercase;
    }

    /* Enhanced Step Numbers */
    .step-number.active {
      color: #ffffff;
      font-weight: 700;
      transform: scale(1.2);
    }

    .step-number.beat-one {
      color: #ff4444;
      font-weight: 700;
    }

    .step-number.beat-one::before {
      content: '●';
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      top: -12px;
      color: #ff4444;
      font-size: 8px;
      animation: pulse 0.8s ease-in-out infinite;
    }

    .step-number.active.beat-one {
      color: #ff6666;
      text-shadow: 0 0 8px rgba(255, 68, 68, 0.6);
    }

    /* Pulsing Background Animations */
    @keyframes beatPulse {
      0% { background-color: #000000; }
      3% { background-color: #0a0a0a; }
      100% { background-color: #000000; }
    }

    @keyframes beatOnePulse {
      0% { background-color: #000000; }
      4% { background-color: #150a0a; }
      100% { background-color: #000000; }
    }

    body.beat-pulse {
      animation: beatPulse 0.12s ease-out;
    }

    body.beat-one-pulse {
      animation: beatOnePulse 0.18s ease-out;
    }

    /* Drum Color Flashes */
    @keyframes kickFlash {
      0%, 100% { box-shadow: none; }
      40% { box-shadow: 0 0 40px rgba(255, 68, 68, 0.4) inset; }
    }

    @keyframes snareFlash {
      0%, 100% { box-shadow: none; }
      40% { box-shadow: 0 0 40px rgba(255, 170, 0, 0.4) inset; }
    }

    @keyframes hihatFlash {
      0%, 100% { box-shadow: none; }
      40% { box-shadow: 0 0 40px rgba(0, 170, 255, 0.4) inset; }
    }

    .sequencer.kick-hit {
      animation: kickFlash 0.15s ease-out;
    }

    .sequencer.snare-hit {
      animation: snareFlash 0.15s ease-out;
    }

    .sequencer.hihat-hit {
      animation: hihatFlash 0.15s ease-out;
    }

    /* Visualization Controls */
    .viz-controls-section {
      border-top: 1px solid var(--border);
      animation: fadeIn 0.8s var(--transition) 0.5s both;
    }

    .viz-controls {
      display: flex;
      gap: 24px;
      padding: 24px 40px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .viz-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 9px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: #666;
      cursor: pointer;
      transition: color 0.2s;
      user-select: none;
    }

    .viz-toggle:hover {
      color: #999;
    }

    .viz-toggle input[type="checkbox"] {
      appearance: none;
      width: 14px;
      height: 14px;
      border: 1px solid #333;
      background: #000;
      cursor: pointer;
      transition: all 0.2s;
    }

    .viz-toggle input[type="checkbox"]:checked {
      background: #fff;
      border-color: #fff;
    }

    .viz-toggle input[type="checkbox"]:checked::after {
      content: '✓';
      display: block;
      text-align: center;
      color: #000;
      font-size: 10px;
      line-height: 14px;
    }

    /* Mobile Optimizations for Visualizations */
    @media (max-width: 768px) {
      .visualization-section {
        padding: 30px 20px;
      }

      .viz-container {
        gap: 40px;
      }

      .beat-circle {
        width: 160px;
        height: 160px;
      }

      .beat-playhead {
        transform-origin: 80px 80px;
      }

      .beat-center-text {
        font-size: 20px;
      }

      .viz-controls {
        gap: 16px;
        padding: 20px;
      }

      /* Reduce animation complexity on mobile */
      .beat-segment {
        transition: fill 0.05s ease-out;
      }
    }
  </style>
</head>
<body>
  <div class="loading">
    <div class="loading-text">INITIALIZING</div>
  </div>

  <div class="container">
    <header class="header">
      <div class="logo">BEAT-BOX</div>
      <div class="status" id="status">READY</div>
    </header>

    <nav class="nav-tabs">
      <button class="nav-tab active" data-view="beatbox">BEAT BOX</button>
      <button class="nav-tab" data-view="fretboard">FRETBOARD</button>
    </nav>

    <!-- Beat Box View -->
    <div id="beatbox-view" class="view active">
    <section class="tempo-section">
      <div class="tempo-container">
        <div class="vertical-volume">
          <div class="volume-value" id="droneVolumeValue">60%</div>
          <div class="volume-track" id="droneVolumeTrack">
            <div class="volume-fill" id="droneVolumeFill" style="height: 60%"></div>
            <div class="volume-thumb" id="droneVolumeThumb" style="bottom: 60%"></div>
          </div>
          <div class="volume-label">DRONE</div>
        </div>
        
        <div class="tempo-display" id="tempoDisplay" tabindex="-1">
          <div class="tempo-value" id="tempoValue">120</div>
          <div class="tempo-label">BPM</div>
          <div class="tap-hint">TAP TO SET TEMPO</div>
        </div>
        
        <div class="vertical-volume">
          <div class="volume-value" id="drumVolumeValue">70%</div>
          <div class="volume-track" id="drumVolumeTrack">
            <div class="volume-fill" id="drumVolumeFill" style="height: 70%"></div>
            <div class="volume-thumb" id="drumVolumeThumb" style="bottom: 70%"></div>
          </div>
          <div class="volume-label">DRUMS</div>
        </div>
      </div>
      
      <button class="play-button" id="playBtn">
        <span class="play-icon"></span>
      </button>
    </section>

    <section class="visualization-section">
      <div class="viz-container">
        <div class="beat-circle-container" id="beatCircleContainer">
          <svg class="beat-circle" viewBox="0 0 200 200" id="beatCircle">
            <!-- Segments and playhead will be generated by JavaScript -->
          </svg>
          <div class="beat-label">BEAT CIRCLE</div>
        </div>
      </div>
    </section>

    <section class="presets">
      <button class="preset-btn" id="preset1">PATTERN 01</button>
      <button class="preset-btn" id="preset2">PATTERN 02</button>
      <button class="preset-btn" id="preset3">PATTERN 03</button>
      <button class="preset-btn" id="stepToggle">4/8 STEPS</button>
    </section>

    <section class="sequencer">
      <div class="step-numbers">
        <div class="number-spacer"></div>
        <div class="numbers-grid" id="stepNumbers"></div>
      </div>
      
      <div class="track" data-track="kick">
        <div class="track-label" data-track="kick">KICK</div>
        <div class="steps" id="kick-steps"></div>
      </div>
      
      <div class="track" data-track="snare">
        <div class="track-label" data-track="snare">SNARE</div>
        <div class="steps" id="snare-steps"></div>
      </div>
      
      <div class="track" data-track="hihat">
        <div class="track-label" data-track="hihat">HI-HAT</div>
        <div class="steps" id="hihat-steps"></div>
      </div>
    </section>

    <section class="controls">
      <div class="control" id="droneControl">
        <div class="control-value" id="droneValue">E2</div>
        <div class="control-label">DRONE</div>
      </div>

      <div class="control" id="droneVolControl">
        <div class="control-value" id="droneVolValue">60%</div>
        <div class="control-label">DRONE VOL</div>
      </div>

      <div class="control" id="drumVolControl">
        <div class="control-value" id="drumVolValue">70%</div>
        <div class="control-label">DRUM VOL</div>
      </div>
    </section>

    <section class="advanced">
      <div class="advanced-toggle" id="advancedToggle">ADVANCED OPTIONS</div>
      
      <div class="advanced-content" id="advancedContent">
        <div class="slider-group">
          <label class="slider-label">TEMPO</label>
          <input type="range" class="slider" id="tempoSlider" min="60" max="180" value="120">
          <div class="slider-value" id="tempoSliderValue">120 BPM</div>
        </div>

        <div class="slider-group">
          <label class="slider-label">DRONE VOLUME</label>
          <input type="range" class="slider" id="droneVolSlider" min="0" max="100" value="60">
          <div class="slider-value" id="droneVolSliderValue">60%</div>
        </div>

        <div class="slider-group">
          <label class="slider-label">DRUM VOLUME</label>
          <input type="range" class="slider" id="drumVolSlider" min="0" max="100" value="70">
          <div class="slider-value" id="drumVolSliderValue">70%</div>
        </div>

        <div class="actions">
          <button class="action-btn" id="tapTempo">TAP TEMPO</button>
        </div>

        <div class="slider-group piano-section">
          <label class="slider-label">DRONE NOTES</label>
          <div class="piano-container" id="pianoContainer">
            <div class="piano-keyboard" id="pianoKeyboard"></div>
            <div class="piano-info">
              <div class="piano-active-notes" id="pianoActiveNotes">E2</div>
              <div class="piano-clear" id="pianoClear">Clear All</div>
            </div>
          </div>
        </div>
        <div class="slider-group">
            <label class="slider-label">DRONE SOUND</label>
            <select class="select" id="droneSoundSelect">
                <option value="pump_organ_wheezy" selected>Pump Organ - Wheezy</option>
                <option value="pump_organ_classic">Pump Organ - Classic</option>
                <option value="pump_organ_church">Pump Organ - Church</option>
                <option value="pump_organ_celeste">Pump Organ - Celeste</option>
                <option value="pump_organ_vox">Pump Organ - Vox Humana</option>
                <option value="pump_organ_harmonium">Harmonium</option>
                <option value="pump_organ_theater">Theater Organ</option>
                <option value="air_organ">Air Organ (old)</option>
                <option value="warm_pad">Warm Pad</option>
                <option value="distorted">Distorted</option>
                <option value="default">Default</option>
            </select>
        </div>

        <div class="slider-group">
          <label class="slider-label">VISUALIZATIONS</label>
          <div class="viz-controls">
            <label class="viz-toggle">
              <input type="checkbox" id="vizBeatCircle" checked>
              <span>BEAT CIRCLE</span>
            </label>
            <label class="viz-toggle">
              <input type="checkbox" id="vizPulse" checked>
              <span>AMBIENT PULSE</span>
            </label>
          </div>
        </div>
      </div>
    </section>
    </div><!-- End Beat Box View -->

    <!-- Fretboard View -->
    <div id="fretboard-view" class="view">
      <div class="fretboard-device">
        <!-- Fretboard Header -->
        <div class="fretboard-header">
          <div class="fretboard-logo">BEAT<span>•</span>BOX <span>/</span> FRETBOARD</div>
          <div class="mode-badge" id="fb-mode-badge">C IONIAN</div>
        </div>

        <!-- Controls -->
        <div class="fretboard-controls">
          <div class="fb-control-group">
            <div class="fb-control-label">Root Note</div>
            <div class="fb-lcd-display" id="fb-lcd-root">C</div>
          </div>
          <div class="fb-control-group">
            <div class="fb-control-label">Scale Type</div>
            <div class="fb-lcd-display">MAJOR</div>
          </div>
          <div class="fb-control-group">
            <div class="fb-control-label">Display</div>
            <div class="fb-button-row">
              <button class="fb-btn active" data-display="note">NOTE</button>
              <button class="fb-btn" data-display="deg">DEG</button>
            </div>
          </div>
        </div>

        <!-- Legend -->
        <div class="fb-legend">
          <div class="fb-legend-item">
            <div class="fb-legend-dot root">R</div>
            <span>Root</span>
          </div>
          <div class="fb-legend-item">
            <div class="fb-legend-dot chord-3">3</div>
            <span>3rd</span>
          </div>
          <div class="fb-legend-item">
            <div class="fb-legend-dot chord-5">5</div>
            <span>5th</span>
          </div>
          <div class="fb-legend-item">
            <div class="fb-legend-dot chord-7">7</div>
            <span>7th</span>
          </div>
          <div class="fb-legend-item">
            <div class="fb-legend-dot passing">–</div>
            <span>2, 4, 6</span>
          </div>
        </div>

        <!-- Rotate hint (mobile portrait only) -->
        <div class="rotate-hint">
          <div class="rotate-icon">📱</div>
          <div class="rotate-text">Rotate your phone for fretboard view</div>
        </div>

        <!-- Fretboard -->
        <div class="fretboard-container">
          <div class="fretboard" id="fretboard">
            <!-- Fret Numbers -->
            <div class="fret-numbers">
              <div class="fret-num"></div>
              <div class="fret-num">0</div>
              <div class="fret-num">1</div>
              <div class="fret-num">2</div>
              <div class="fret-num marker">3</div>
              <div class="fret-num">4</div>
              <div class="fret-num marker">5</div>
              <div class="fret-num">6</div>
              <div class="fret-num marker">7</div>
              <div class="fret-num">8</div>
              <div class="fret-num marker">9</div>
              <div class="fret-num">10</div>
              <div class="fret-num">11</div>
              <div class="fret-num marker">12</div>
              <div class="fret-num">13</div>
              <div class="fret-num">14</div>
            </div>
            <!-- Strings generated by JavaScript -->
          </div>
        </div>

        <!-- Mode Selector -->
        <div class="mode-info">
          <div class="mode-card active" data-mode="ionian" data-root="C" data-degree="1">
            <span class="note-name">C</span>
            <span class="name">Ionian</span>
          </div>
          <div class="mode-card" data-mode="dorian" data-root="D" data-degree="2">
            <span class="note-name">D</span>
            <span class="name">Dorian</span>
          </div>
          <div class="mode-card" data-mode="phrygian" data-root="E" data-degree="3">
            <span class="note-name">E</span>
            <span class="name">Phrygian</span>
          </div>
          <div class="mode-card" data-mode="lydian" data-root="F" data-degree="4">
            <span class="note-name">F</span>
            <span class="name">Lydian</span>
          </div>
          <div class="mode-card" data-mode="mixolydian" data-root="G" data-degree="5">
            <span class="note-name">G</span>
            <span class="name">Mixolydian</span>
          </div>
          <div class="mode-card" data-mode="aeolian" data-root="A" data-degree="6">
            <span class="note-name">A</span>
            <span class="name">Aeolian</span>
          </div>
          <div class="mode-card" data-mode="locrian" data-root="B" data-degree="7">
            <span class="note-name">B</span>
            <span class="name">Locrian</span>
          </div>
        </div>

        <!-- Scale Pattern -->
        <div class="fb-pattern-display">
          <div class="fb-pattern-row">
            <div class="fb-pattern-label">Pattern</div>
            <div class="intervals" id="fb-pattern-intervals">
              <div class="interval whole">W</div>
              <div class="interval whole">W</div>
              <div class="interval half">H</div>
              <div class="interval whole">W</div>
              <div class="interval whole">W</div>
              <div class="interval whole">W</div>
              <div class="interval half">H</div>
            </div>
          </div>
          <div class="fb-pattern-row">
            <div class="fb-pattern-label">Notes</div>
            <div class="intervals" id="fb-pattern-notes">
              <!-- Generated by JS -->
            </div>
          </div>
        </div>

        <!-- Footer -->
        <div class="fretboard-footer">
          <span id="fb-current-mode">C MAJOR / IONIAN MODE</span>
          <span>STANDARD TUNING</span>
        </div>
      </div>
    </div><!-- End Fretboard View -->

  </div>

  <script>
  (() => {
    'use strict';
    
    // Audio Context and State
    let audioCtx = null;
    let isPlaying = false;
    let currentStep = 0;
    let bpm = 120;
    let nextNoteTime = 0;
    let schedulerTimer = null;
    let unlocked = false;
    
    // Pattern State
    let STEPS = 8;
    const patterns = {
      kick: new Array(8).fill(false),
      snare: new Array(8).fill(false),
      hihat: new Array(8).fill(false)
    };
    
    const muted = {
      kick: false,
      snare: false,
      hihat: false
    };
    
    // Audio Nodes
    let masterGain = null;
    let compressor = null;
    let activeDrone = null; // Will store the current drone's nodes and gain controls
    let droneGain = 0.6;
    let drumGain = 0.7;
    let droneNotes = new Set(['E2']); // Support multiple notes (chords)
    let droneSound = 'pump_organ_wheezy';

    // Note Frequencies - 2 full octaves (C2 to C4)
    const noteFreqs = {
      'C2': 65.41, 'C#2': 69.30, 'D2': 73.42, 'D#2': 77.78,
      'E2': 82.41, 'F2': 87.31, 'F#2': 92.50, 'G2': 98.00,
      'G#2': 103.83, 'A2': 110.00, 'A#2': 116.54, 'B2': 123.47,
      'C3': 130.81, 'C#3': 138.59, 'D3': 146.83, 'D#3': 155.56,
      'E3': 164.81, 'F3': 174.61, 'F#3': 185.00, 'G3': 196.00,
      'G#3': 207.65, 'A3': 220.00, 'A#3': 233.08, 'B3': 246.94,
      'C4': 261.63
    };

    // Piano keyboard layout (2 full octaves: C2 to C4 = 25 keys total)
    const pianoLayout = [
      // Octave 1 (C2-B2)
      { note: 'C2', type: 'white', pos: 0 },
      { note: 'C#2', type: 'black', pos: 0.7 },
      { note: 'D2', type: 'white', pos: 1 },
      { note: 'D#2', type: 'black', pos: 1.7 },
      { note: 'E2', type: 'white', pos: 2 },
      { note: 'F2', type: 'white', pos: 3 },
      { note: 'F#2', type: 'black', pos: 3.7 },
      { note: 'G2', type: 'white', pos: 4 },
      { note: 'G#2', type: 'black', pos: 4.7 },
      { note: 'A2', type: 'white', pos: 5 },
      { note: 'A#2', type: 'black', pos: 5.7 },
      { note: 'B2', type: 'white', pos: 6 },
      // Octave 2 (C3-B3) - Middle C octave
      { note: 'C3', type: 'white', pos: 7 },
      { note: 'C#3', type: 'black', pos: 7.7 },
      { note: 'D3', type: 'white', pos: 8 },
      { note: 'D#3', type: 'black', pos: 8.7 },
      { note: 'E3', type: 'white', pos: 9 },
      { note: 'F3', type: 'white', pos: 10 },
      { note: 'F#3', type: 'black', pos: 10.7 },
      { note: 'G3', type: 'white', pos: 11 },
      { note: 'G#3', type: 'black', pos: 11.7 },
      { note: 'A3', type: 'white', pos: 12 },
      { note: 'A#3', type: 'black', pos: 12.7 },
      { note: 'B3', type: 'white', pos: 13 },
      // C4 (top note)
      { note: 'C4', type: 'white', pos: 14 }
    ];
    
    // DOM Elements
    const $ = id => document.getElementById(id);
    const playBtn = $('playBtn');
    const status = $('status');
    const tempoValue = $('tempoValue');
    const tempoSlider = $('tempoSlider');
    const tempoSliderValue = $('tempoSliderValue');
    const droneValue = $('droneValue');
    const droneVolValue = $('droneVolValue');
    const droneVolSlider = $('droneVolSlider');
    const droneVolSliderValue = $('droneVolSliderValue');
    const drumVolValue = $('drumVolValue');
    const drumVolSlider = $('drumVolSlider');
    const drumVolSliderValue = $('drumVolSliderValue');
    const advancedToggle = $('advancedToggle');
    const advancedContent = $('advancedContent');
    
    // Initialize Audio Context
    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        compressor = audioCtx.createDynamicsCompressor();
        compressor.threshold.value = -24;
        compressor.knee.value = 30;
        compressor.ratio.value = 12;
        compressor.attack.value = 0.003;
        compressor.release.value = 0.25;
        
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.9;
        
        compressor.connect(masterGain);
        masterGain.connect(audioCtx.destination);
      }
      return audioCtx;
    }
    
    // Unlock iOS Audio
    function unlockAudio() {
      if (unlocked) return;
      const ctx = initAudio();
      const buffer = ctx.createBuffer(1, 1, ctx.sampleRate);
      const source = ctx.createBufferSource();
      source.buffer = buffer;
      source.connect(ctx.destination);
      source.start(0);
      unlocked = true;
    }
    
    // Drum Synthesis
    function playKick(time) {
      if (muted.kick) return;
      const ctx = audioCtx;
      
      // Tone oscillator
      const osc = ctx.createOscillator();
      osc.frequency.setValueAtTime(150, time);
      osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
      
      // Click oscillator for punch
      const click = ctx.createOscillator();
      click.frequency.setValueAtTime(1500, time);
      click.frequency.exponentialRampToValueAtTime(100, time + 0.02);
      
      // Gain envelopes
      const oscGain = ctx.createGain();
      oscGain.gain.setValueAtTime(drumGain, time);
      oscGain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
      
      const clickGain = ctx.createGain();
      clickGain.gain.setValueAtTime(drumGain * 0.3, time);
      clickGain.gain.exponentialRampToValueAtTime(0.01, time + 0.02);
      
      // Connect
      osc.connect(oscGain);
      oscGain.connect(compressor);
      
      click.connect(clickGain);
      clickGain.connect(compressor);
      
      // Schedule
      osc.start(time);
      osc.stop(time + 0.5);
      click.start(time);
      click.stop(time + 0.03);
    }
    
    function playSnare(time) {
      if (muted.snare) return;
      const ctx = audioCtx;
      
      // Noise buffer
      const bufferSize = ctx.sampleRate * 0.15;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
      }
      
      const noise = ctx.createBufferSource();
      noise.buffer = buffer;
      
      // Tone component
      const osc = ctx.createOscillator();
      osc.frequency.value = 200;
      osc.type = 'triangle';
      
      // Filters
      const highpass = ctx.createBiquadFilter();
      highpass.type = 'highpass';
      highpass.frequency.value = 1000;
      
      const bandpass = ctx.createBiquadFilter();
      bandpass.type = 'bandpass';
      bandpass.frequency.value = 3000;
      bandpass.Q.value = 2;
      
      // Gain envelopes
      const noiseGain = ctx.createGain();
      noiseGain.gain.setValueAtTime(drumGain * 0.8, time);
      noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
      
      const oscGain = ctx.createGain();
      oscGain.gain.setValueAtTime(drumGain * 0.3, time);
      oscGain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
      
      // Connect
      noise.connect(highpass);
      highpass.connect(bandpass);
      bandpass.connect(noiseGain);
      noiseGain.connect(compressor);
      
      osc.connect(oscGain);
      oscGain.connect(compressor);
      
      // Schedule
      noise.start(time);
      osc.start(time);
      osc.stop(time + 0.1);
    }
    
    function playHiHat(time) {
      if (muted.hihat) return;
      const ctx = audioCtx;
      
      // Noise buffer
      const bufferSize = ctx.sampleRate * 0.05;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      
      for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 3);
      }
      
      const noise = ctx.createBufferSource();
      noise.buffer = buffer;
      
      // Filters for metallic sound
      const highpass = ctx.createBiquadFilter();
      highpass.type = 'highpass';
      highpass.frequency.value = 8000;
      highpass.Q.value = 0.7;
      
      const bandpass = ctx.createBiquadFilter();
      bandpass.type = 'bandpass';
      bandpass.frequency.value = 10000;
      bandpass.Q.value = 1.5;
      
      // Gain envelope
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(drumGain * 0.5, time);
      gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
      
      // Connect
      noise.connect(highpass);
      highpass.connect(bandpass);
      bandpass.connect(gain);
      gain.connect(compressor);
      
      // Schedule
      noise.start(time);
    }
    
    // Drone Synthesis - Multi-note (Chord) Support
    function createAirOrganDrone(ctx, notes, volume) {
      const nodes = [];
      const gainNodes = [];
      const gainReduction = Math.max(0.5, 1 / Math.sqrt(notes.size));

      // Shared LFO for vibrato
      const lfo = ctx.createOscillator();
      lfo.frequency.value = 5; // Vibrato speed
      lfo.type = 'sine';

      const lfoGain = ctx.createGain();
      lfoGain.gain.value = 8; // Vibrato depth
      lfo.connect(lfoGain);

      notes.forEach(note => {
        const freq = noteFreqs[note];
        if (!freq) return;

        // Oscillators
        const osc1 = ctx.createOscillator(); // Fundamental
        osc1.type = 'sine';
        osc1.frequency.value = freq;
        osc1.detune.value = -4;

        const osc2 = ctx.createOscillator(); // Octave up
        osc2.type = 'sine';
        osc2.frequency.value = freq * 2;
        osc2.detune.value = 4;

        const osc3 = ctx.createOscillator(); // Sub-octave
        osc3.type = 'sine';
        osc3.frequency.value = freq * 0.5;

        // Connect LFO individually to each oscillator's detune parameter
        lfoGain.connect(osc1.detune);
        lfoGain.connect(osc2.detune);
        lfoGain.connect(osc3.detune);

        // Gain nodes for mixing
        const gain1 = ctx.createGain();
        gain1.gain.setValueAtTime(0.001, ctx.currentTime);
        gain1.gain.exponentialRampToValueAtTime(volume * 0.7 * gainReduction, ctx.currentTime + 0.8);

        const gain2 = ctx.createGain();
        gain2.gain.setValueAtTime(0.001, ctx.currentTime);
        gain2.gain.exponentialRampToValueAtTime(volume * 0.4 * gainReduction, ctx.currentTime + 0.8);

        const gain3 = ctx.createGain();
        gain3.gain.setValueAtTime(0.001, ctx.currentTime);
        gain3.gain.exponentialRampToValueAtTime(volume * 0.5 * gainReduction, ctx.currentTime + 0.8);

        osc1.connect(gain1);
        osc2.connect(gain2);
        osc3.connect(gain3);

        nodes.push(osc1, osc2, osc3, gain1, gain2, gain3);
        gainNodes.push(gain1, gain2, gain3); // For volume control
      });

      // Shared filter
      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 2200;
      filter.Q.value = 3;

      // Master gain for this sound
      const mixGain = ctx.createGain();

      // Connect all individual gain nodes to the mix gain
      gainNodes.forEach(gainNode => {
        gainNode.connect(mixGain);
      });

      mixGain.connect(filter);
      filter.connect(compressor);

      // Start oscillators and LFO
      lfo.start();
      nodes.forEach(node => {
        if (node.start) node.start();
      });

      return {
        nodes: [...nodes, filter, lfo, lfoGain, mixGain],
        gainNodes: gainNodes,
        gainRamps: [0.7, 0.4, 0.5] // Store initial mix ratios
      };
    }

    function createWarmPadDrone(ctx, notes, volume) {
      const nodes = [];
      const gainNodes = [];
      const gainReduction = Math.max(0.5, 1 / Math.sqrt(notes.size));

      notes.forEach(note => {
        const freq = noteFreqs[note];
        if (!freq) return;

        // Detuned sawtooth oscillators for a wide, warm sound
        const osc1 = ctx.createOscillator();
        osc1.type = 'sawtooth';
        osc1.frequency.value = freq;
        osc1.detune.value = -7; // Detune down

        const osc2 = ctx.createOscillator();
        osc2.type = 'sawtooth';
        osc2.frequency.value = freq;
        osc2.detune.value = 7; // Detune up

        // A single gain node for each note's oscillator pair
        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.001, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(volume * 0.5 * gainReduction, ctx.currentTime + 1.2);

        osc1.connect(gain);
        osc2.connect(gain);
        nodes.push(osc1, osc2, gain);
        gainNodes.push(gain);
      });

      // A sweeping lowpass filter for a classic pad sound.
      // No LFO is used; the filter sweep provides the primary movement.
      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.Q.value = 5;
      filter.frequency.setValueAtTime(100, ctx.currentTime);
      filter.frequency.linearRampToValueAtTime(800, ctx.currentTime + 2); // Slow sweep up

      const mixGain = ctx.createGain();

      gainNodes.forEach(gainNode => {
        gainNode.connect(mixGain);
      });

      mixGain.connect(filter);
      filter.connect(compressor);

      nodes.forEach(node => {
        if (node.start) node.start();
      });

      return {
        nodes: [...nodes, filter, mixGain],
        gainNodes: gainNodes,
        gainRamps: [0.5] // Single gain ramp for this sound
      };
    }

    // Pre-calculate the distortion curve once to save resources
    const distortionCurve = (() => {
      const curve = new Float32Array(256);
      for (let i = 0; i < 256; i++) {
        const x = i * 2 / 255 - 1;
        // A common waveshaper curve formula
        curve[i] = (Math.PI + 15) * x / (Math.PI + 15 * Math.abs(x));
      }
      return curve;
    })();

    function createDistortedDrone(ctx, notes, volume) {
      const nodes = [];
      const gainNodes = [];
      const gainReduction = Math.max(0.5, 1 / Math.sqrt(notes.size));

      notes.forEach(note => {
        const freq = noteFreqs[note];
        if (!freq) return;

        const osc = ctx.createOscillator();
        osc.type = 'square';
        osc.frequency.value = freq;

        const gain = ctx.createGain();
        gain.gain.setValueAtTime(0.001, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(volume * 0.6 * gainReduction, ctx.currentTime + 0.5);

        osc.connect(gain);
        nodes.push(osc, gain);
        gainNodes.push(gain);
      });

      // Aggressive distortion for a gritty sound
      const distortion = ctx.createWaveShaper();
      distortion.curve = distortionCurve; // Use the cached curve
      distortion.oversample = '4x';

      // Lowpass filter to tame high frequencies
      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 1500;

      const mixGain = ctx.createGain();

      gainNodes.forEach(gainNode => {
        gainNode.connect(mixGain);
      });

      mixGain.connect(distortion);
      distortion.connect(filter);
      filter.connect(compressor);

      nodes.forEach(node => {
        if (node.start) node.start();
      });

      return {
        nodes: [...nodes, distortion, filter, mixGain],
        gainNodes: gainNodes,
        gainRamps: [0.6]
      };
    }

    function createDefaultDrone(ctx, notes, volume) {
      const allNodes = [];
      const gainNodes = [];
      const gainReduction = Math.max(0.5, 1 / Math.sqrt(notes.size));

      notes.forEach(note => {
        const freq = noteFreqs[note];
        if (!freq) return;

        // A mix of classic waveforms
        const osc1 = ctx.createOscillator();
        osc1.type = 'sawtooth';
        osc1.frequency.value = freq;
        osc1.detune.value = -2;

        const osc2 = ctx.createOscillator();
        osc2.type = 'square';
        osc2.frequency.value = freq * 2.01; // Slightly detuned octave up

        const osc3 = ctx.createOscillator();
        osc3.type = 'triangle';
        osc3.frequency.value = freq * 0.5; // Sub-octave

        // Individual gain controls for mixing
        const gain1 = ctx.createGain();
        gain1.gain.setValueAtTime(0.001, ctx.currentTime);
        gain1.gain.exponentialRampToValueAtTime(volume * 0.5 * gainReduction, ctx.currentTime + 0.5);

        const gain2 = ctx.createGain();
        gain2.gain.setValueAtTime(0.001, ctx.currentTime);
        gain2.gain.exponentialRampToValueAtTime(volume * 0.3 * gainReduction, ctx.currentTime + 0.5);

        const gain3 = ctx.createGain();
        gain3.gain.setValueAtTime(0.001, ctx.currentTime);
        gain3.gain.exponentialRampToValueAtTime(volume * 0.6 * gainReduction, ctx.currentTime + 0.5);

        osc1.connect(gain1);
        osc2.connect(gain2);
        osc3.connect(gain3);

        osc1.start();
        osc2.start();
        osc3.start();

        allNodes.push(osc1, osc2, osc3, gain1, gain2, gain3);
        gainNodes.push(gain1, gain2, gain3);
      });

      const mixGain = ctx.createGain();
      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 2000;
      filter.Q.value = 2;

      // Chorus/delay effect for spaciousness
      const delay = ctx.createDelay(0.1);
      delay.delayTime.value = 0.01;
      const lfo = ctx.createOscillator();
      lfo.frequency.value = 0.5; // Slow modulation
      const lfoGain = ctx.createGain();
      lfoGain.gain.value = 0.002; // Subtle depth
      lfo.connect(lfoGain);
      lfoGain.connect(delay.delayTime);

      gainNodes.forEach(gainNode => {
        gainNode.connect(mixGain);
      });

      mixGain.connect(filter);
      filter.connect(compressor);
      mixGain.connect(delay);
      delay.connect(filter); // Feedback loop for chorus effect

      lfo.start();
      return {
        nodes: [...allNodes, mixGain, filter, delay, lfo, lfoGain],
        gainNodes: gainNodes,
        gainRamps: [0.5, 0.3, 0.6]
      };
    }

    // PUMP ORGAN VARIATIONS - Multiple creative interpretations

    function createPumpOrganClassic(ctx, notes, volume) {
      // Classic pump organ: Slow attack, gentle air pressure wobble, harmonic series
      const nodes = [];
      const gainNodes = [];
      const gainReduction = Math.max(0.5, 1 / Math.sqrt(notes.size));

      // Slow air pressure wobble (like manual pumping)
      const pressureLFO = ctx.createOscillator();
      pressureLFO.frequency.value = 0.5; // Slow wobble
      pressureLFO.type = 'sine';

      const pressureGain = ctx.createGain();
      pressureGain.gain.value = 3; // Subtle pitch variation from air pressure
      pressureLFO.connect(pressureGain);

      notes.forEach(note => {
        const freq = noteFreqs[note];
        if (!freq) return;

        // Harmonic series like organ pipes (1st, 2nd, 3rd harmonics)
        const fundamental = ctx.createOscillator();
        fundamental.type = 'sine';
        fundamental.frequency.value = freq;

        const harmonic2 = ctx.createOscillator();
        harmonic2.type = 'sine';
        harmonic2.frequency.value = freq * 2; // Octave

        const harmonic3 = ctx.createOscillator();
        harmonic3.type = 'sine';
        harmonic3.frequency.value = freq * 3; // 12th (octave + fifth)

        // Connect air pressure LFO to each oscillator
        pressureGain.connect(fundamental.detune);
        pressureGain.connect(harmonic2.detune);
        pressureGain.connect(harmonic3.detune);

        // Slow attack simulating air filling the bellows
        const gain1 = ctx.createGain();
        gain1.gain.setValueAtTime(0.001, ctx.currentTime);
        gain1.gain.exponentialRampToValueAtTime(volume * 0.7 * gainReduction, ctx.currentTime + 1.5);

        const gain2 = ctx.createGain();
        gain2.gain.setValueAtTime(0.001, ctx.currentTime);
        gain2.gain.exponentialRampToValueAtTime(volume * 0.45 * gainReduction, ctx.currentTime + 1.5);

        const gain3 = ctx.createGain();
        gain3.gain.setValueAtTime(0.001, ctx.currentTime);
        gain3.gain.exponentialRampToValueAtTime(volume * 0.35 * gainReduction, ctx.currentTime + 1.5);

        fundamental.connect(gain1);
        harmonic2.connect(gain2);
        harmonic3.connect(gain3);

        nodes.push(fundamental, harmonic2, harmonic3, gain1, gain2, gain3);
        gainNodes.push(gain1, gain2, gain3);
      });

      // Warm lowpass filter
      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 1800;
      filter.Q.value = 2;

      const mixGain = ctx.createGain();

      // Post-filter gain to compensate for filter loss and match default volume
      const outputGain = ctx.createGain();
      outputGain.gain.value = 1.4; // Boost to match default

      gainNodes.forEach(gn => gn.connect(mixGain));
      mixGain.connect(filter);
      filter.connect(outputGain);
      outputGain.connect(compressor);

      pressureLFO.start();
      nodes.forEach(node => { if (node.start) node.start(); });

      return {
        nodes: [...nodes, filter, mixGain, outputGain, pressureLFO, pressureGain],
        gainNodes: gainNodes,
        gainRamps: [0.7, 0.45, 0.35]
      };
    }

    function createPumpOrganWheezy(ctx, notes, volume) {
      // Wheezy old pump organ: Very slow attack, exaggerated air wobble, vintage character
      const nodes = [];
      const gainNodes = [];
      const gainReduction = Math.max(0.5, 1 / Math.sqrt(notes.size));

      // Exaggerated wheezy air pressure variation
      const wheezeLFO = ctx.createOscillator();
      wheezeLFO.frequency.value = 0.3; // Even slower, irregular breathing
      wheezeLFO.type = 'triangle'; // More abrupt pressure changes

      const wheezeGain = ctx.createGain();
      wheezeGain.gain.value = 8; // Exaggerated pitch wobble
      wheezeLFO.connect(wheezeGain);

      notes.forEach(note => {
        const freq = noteFreqs[note];
        if (!freq) return;

        // Slightly detuned harmonics for vintage character
        const osc1 = ctx.createOscillator();
        osc1.type = 'sine';
        osc1.frequency.value = freq;
        osc1.detune.value = -3;

        const osc2 = ctx.createOscillator();
        osc2.type = 'sine';
        osc2.frequency.value = freq * 2;
        osc2.detune.value = 5;

        const osc3 = ctx.createOscillator();
        osc3.type = 'sine';
        osc3.frequency.value = freq * 4; // Higher harmonic for brightness
        osc3.detune.value = -2;

        wheezeGain.connect(osc1.detune);
        wheezeGain.connect(osc2.detune);
        wheezeGain.connect(osc3.detune);

        // Very slow attack - really struggles to fill with air
        const gain1 = ctx.createGain();
        gain1.gain.setValueAtTime(0.001, ctx.currentTime);
        gain1.gain.exponentialRampToValueAtTime(volume * 0.8 * gainReduction, ctx.currentTime + 2.5);

        const gain2 = ctx.createGain();
        gain2.gain.setValueAtTime(0.001, ctx.currentTime);
        gain2.gain.exponentialRampToValueAtTime(volume * 0.5 * gainReduction, ctx.currentTime + 2.5);

        const gain3 = ctx.createGain();
        gain3.gain.setValueAtTime(0.001, ctx.currentTime);
        gain3.gain.exponentialRampToValueAtTime(volume * 0.25 * gainReduction, ctx.currentTime + 2.5);

        osc1.connect(gain1);
        osc2.connect(gain2);
        osc3.connect(gain3);

        nodes.push(osc1, osc2, osc3, gain1, gain2, gain3);
        gainNodes.push(gain1, gain2, gain3);
      });

      // Darker filter for vintage sound
      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 1400;
      filter.Q.value = 3;

      const mixGain = ctx.createGain();

      // Post-filter gain to compensate for aggressive filtering
      const outputGain = ctx.createGain();
      outputGain.gain.value = 1.6; // Extra boost for dark filter

      gainNodes.forEach(gn => gn.connect(mixGain));
      mixGain.connect(filter);
      filter.connect(outputGain);
      outputGain.connect(compressor);

      wheezeLFO.start();
      nodes.forEach(node => { if (node.start) node.start(); });

      return {
        nodes: [...nodes, filter, mixGain, outputGain, wheezeLFO, wheezeGain],
        gainNodes: gainNodes,
        gainRamps: [0.8, 0.5, 0.25]
      };
    }

    function createPumpOrganChurch(ctx, notes, volume) {
      // Church reed organ: Rich harmonics, multiple ranks, stable and powerful
      const nodes = [];
      const gainNodes = [];
      const gainReduction = Math.max(0.5, 1 / Math.sqrt(notes.size));

      // Minimal LFO for natural slight variation
      const lfo = ctx.createOscillator();
      lfo.frequency.value = 0.8;
      lfo.type = 'sine';

      const lfoGain = ctx.createGain();
      lfoGain.gain.value = 2; // Very subtle
      lfo.connect(lfoGain);

      notes.forEach(note => {
        const freq = noteFreqs[note];
        if (!freq) return;

        // Full harmonic series like pipe organ
        const harm1 = ctx.createOscillator(); // Fundamental
        harm1.type = 'sine';
        harm1.frequency.value = freq;

        const harm2 = ctx.createOscillator(); // 2nd harmonic (octave)
        harm2.type = 'sine';
        harm2.frequency.value = freq * 2;

        const harm3 = ctx.createOscillator(); // 3rd harmonic (12th)
        harm3.type = 'sine';
        harm3.frequency.value = freq * 3;

        const harm4 = ctx.createOscillator(); // 4th harmonic (15th)
        harm4.type = 'sine';
        harm4.frequency.value = freq * 4;

        // LFO for subtle warmth
        lfoGain.connect(harm1.detune);
        lfoGain.connect(harm2.detune);
        lfoGain.connect(harm3.detune);
        lfoGain.connect(harm4.detune);

        // Medium-slow attack
        const gain1 = ctx.createGain();
        gain1.gain.setValueAtTime(0.001, ctx.currentTime);
        gain1.gain.exponentialRampToValueAtTime(volume * 0.55 * gainReduction, ctx.currentTime + 1.0);

        const gain2 = ctx.createGain();
        gain2.gain.setValueAtTime(0.001, ctx.currentTime);
        gain2.gain.exponentialRampToValueAtTime(volume * 0.4 * gainReduction, ctx.currentTime + 1.0);

        const gain3 = ctx.createGain();
        gain3.gain.setValueAtTime(0.001, ctx.currentTime);
        gain3.gain.exponentialRampToValueAtTime(volume * 0.3 * gainReduction, ctx.currentTime + 1.0);

        const gain4 = ctx.createGain();
        gain4.gain.setValueAtTime(0.001, ctx.currentTime);
        gain4.gain.exponentialRampToValueAtTime(volume * 0.2 * gainReduction, ctx.currentTime + 1.0);

        harm1.connect(gain1);
        harm2.connect(gain2);
        harm3.connect(gain3);
        harm4.connect(gain4);

        nodes.push(harm1, harm2, harm3, harm4, gain1, gain2, gain3, gain4);
        gainNodes.push(gain1, gain2, gain3, gain4);
      });

      // Moderate filter
      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 2500;
      filter.Q.value = 2;

      const mixGain = ctx.createGain();

      // Post-filter gain to match default volume
      const outputGain = ctx.createGain();
      outputGain.gain.value = 1.3;

      gainNodes.forEach(gn => gn.connect(mixGain));
      mixGain.connect(filter);
      filter.connect(outputGain);
      outputGain.connect(compressor);

      lfo.start();
      nodes.forEach(node => { if (node.start) node.start(); });

      return {
        nodes: [...nodes, filter, mixGain, outputGain, lfo, lfoGain],
        gainNodes: gainNodes,
        gainRamps: [0.55, 0.4, 0.3, 0.2]
      };
    }

    function createPumpOrganCeleste(ctx, notes, volume) {
      // Celeste stop: Detuned ranks create shimmering, chorus-like effect
      const nodes = [];
      const gainNodes = [];
      const gainReduction = Math.max(0.5, 1 / Math.sqrt(notes.size));

      // Slow LFO for gentle movement
      const lfo = ctx.createOscillator();
      lfo.frequency.value = 0.6;
      lfo.type = 'sine';

      const lfoGain = ctx.createGain();
      lfoGain.gain.value = 4;
      lfo.connect(lfoGain);

      notes.forEach(note => {
        const freq = noteFreqs[note];
        if (!freq) return;

        // Two detuned "ranks" per note for celeste effect
        const osc1a = ctx.createOscillator();
        osc1a.type = 'sine';
        osc1a.frequency.value = freq;
        osc1a.detune.value = -8; // Detuned down

        const osc1b = ctx.createOscillator();
        osc1b.type = 'sine';
        osc1b.frequency.value = freq;
        osc1b.detune.value = 8; // Detuned up

        const osc2a = ctx.createOscillator();
        osc2a.type = 'sine';
        osc2a.frequency.value = freq * 2;
        osc2a.detune.value = -6;

        const osc2b = ctx.createOscillator();
        osc2b.type = 'sine';
        osc2b.frequency.value = freq * 2;
        osc2b.detune.value = 6;

        // Connect LFO
        lfoGain.connect(osc1a.detune);
        lfoGain.connect(osc1b.detune);
        lfoGain.connect(osc2a.detune);
        lfoGain.connect(osc2b.detune);

        // Gentle attack
        const gain1 = ctx.createGain();
        gain1.gain.setValueAtTime(0.001, ctx.currentTime);
        gain1.gain.exponentialRampToValueAtTime(volume * 0.4 * gainReduction, ctx.currentTime + 1.2);

        const gain2 = ctx.createGain();
        gain2.gain.setValueAtTime(0.001, ctx.currentTime);
        gain2.gain.exponentialRampToValueAtTime(volume * 0.4 * gainReduction, ctx.currentTime + 1.2);

        const gain3 = ctx.createGain();
        gain3.gain.setValueAtTime(0.001, ctx.currentTime);
        gain3.gain.exponentialRampToValueAtTime(volume * 0.3 * gainReduction, ctx.currentTime + 1.2);

        const gain4 = ctx.createGain();
        gain4.gain.setValueAtTime(0.001, ctx.currentTime);
        gain4.gain.exponentialRampToValueAtTime(volume * 0.3 * gainReduction, ctx.currentTime + 1.2);

        osc1a.connect(gain1);
        osc1b.connect(gain2);
        osc2a.connect(gain3);
        osc2b.connect(gain4);

        nodes.push(osc1a, osc1b, osc2a, osc2b, gain1, gain2, gain3, gain4);
        gainNodes.push(gain1, gain2, gain3, gain4);
      });

      // Brighter filter for shimmer
      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 2800;
      filter.Q.value = 1.5;

      const mixGain = ctx.createGain();

      // Post-filter gain to match default volume
      const outputGain = ctx.createGain();
      outputGain.gain.value = 1.2;

      gainNodes.forEach(gn => gn.connect(mixGain));
      mixGain.connect(filter);
      filter.connect(outputGain);
      outputGain.connect(compressor);

      lfo.start();
      nodes.forEach(node => { if (node.start) node.start(); });

      return {
        nodes: [...nodes, filter, mixGain, outputGain, lfo, lfoGain],
        gainNodes: gainNodes,
        gainRamps: [0.4, 0.4, 0.3, 0.3]
      };
    }

    function createPumpOrganVox(ctx, notes, volume) {
      // Vox Humana stop: Voice-like quality with formant filtering
      const nodes = [];
      const gainNodes = [];
      const gainReduction = Math.max(0.5, 1 / Math.sqrt(notes.size));

      // Tremolo for vocal vibrato
      const tremolo = ctx.createOscillator();
      tremolo.frequency.value = 4.5; // Vocal vibrato rate
      tremolo.type = 'sine';

      const tremoloGain = ctx.createGain();
      tremoloGain.gain.value = 6;
      tremolo.connect(tremoloGain);

      notes.forEach(note => {
        const freq = noteFreqs[note];
        if (!freq) return;

        // Harmonics that emphasize vocal formants
        const osc1 = ctx.createOscillator();
        osc1.type = 'sine';
        osc1.frequency.value = freq;

        const osc2 = ctx.createOscillator();
        osc2.type = 'sine';
        osc2.frequency.value = freq * 2;

        const osc3 = ctx.createOscillator();
        osc3.type = 'sine';
        osc3.frequency.value = freq * 3;

        const osc4 = ctx.createOscillator(); // Add nasality
        osc4.type = 'sine';
        osc4.frequency.value = freq * 5;

        tremoloGain.connect(osc1.detune);
        tremoloGain.connect(osc2.detune);
        tremoloGain.connect(osc3.detune);
        tremoloGain.connect(osc4.detune);

        // Medium attack
        const gain1 = ctx.createGain();
        gain1.gain.setValueAtTime(0.001, ctx.currentTime);
        gain1.gain.exponentialRampToValueAtTime(volume * 0.55 * gainReduction, ctx.currentTime + 1.0);

        const gain2 = ctx.createGain();
        gain2.gain.setValueAtTime(0.001, ctx.currentTime);
        gain2.gain.exponentialRampToValueAtTime(volume * 0.45 * gainReduction, ctx.currentTime + 1.0);

        const gain3 = ctx.createGain();
        gain3.gain.setValueAtTime(0.001, ctx.currentTime);
        gain3.gain.exponentialRampToValueAtTime(volume * 0.35 * gainReduction, ctx.currentTime + 1.0);

        const gain4 = ctx.createGain();
        gain4.gain.setValueAtTime(0.001, ctx.currentTime);
        gain4.gain.exponentialRampToValueAtTime(volume * 0.2 * gainReduction, ctx.currentTime + 1.0);

        osc1.connect(gain1);
        osc2.connect(gain2);
        osc3.connect(gain3);
        osc4.connect(gain4);

        nodes.push(osc1, osc2, osc3, osc4, gain1, gain2, gain3, gain4);
        gainNodes.push(gain1, gain2, gain3, gain4);
      });

      // Bandpass filter to simulate vocal formant
      const formantFilter = ctx.createBiquadFilter();
      formantFilter.type = 'bandpass';
      formantFilter.frequency.value = 1200; // Vowel-like formant
      formantFilter.Q.value = 4; // Narrow for nasal quality

      const mixGain = ctx.createGain();

      // Post-filter gain to compensate for bandpass loss
      const outputGain = ctx.createGain();
      outputGain.gain.value = 2.5; // Bandpass filters cut a lot of volume

      gainNodes.forEach(gn => gn.connect(mixGain));
      mixGain.connect(formantFilter);
      formantFilter.connect(outputGain);
      outputGain.connect(compressor);

      tremolo.start();
      nodes.forEach(node => { if (node.start) node.start(); });

      return {
        nodes: [...nodes, formantFilter, mixGain, outputGain, tremolo, tremoloGain],
        gainNodes: gainNodes,
        gainRamps: [0.55, 0.45, 0.35, 0.2]
      };
    }

    function createPumpOrganHarmonium(ctx, notes, volume) {
      // Indian harmonium: Continuous drone, nasal quality, rich harmonics
      const nodes = [];
      const gainNodes = [];
      const gainReduction = Math.max(0.5, 1 / Math.sqrt(notes.size));

      // Very subtle LFO for natural variation
      const lfo = ctx.createOscillator();
      lfo.frequency.value = 0.4;
      lfo.type = 'sine';

      const lfoGain = ctx.createGain();
      lfoGain.gain.value = 2;
      lfo.connect(lfoGain);

      notes.forEach(note => {
        const freq = noteFreqs[note];
        if (!freq) return;

        // Rich harmonic content for nasal quality
        const harm1 = ctx.createOscillator();
        harm1.type = 'sine';
        harm1.frequency.value = freq;

        const harm2 = ctx.createOscillator();
        harm2.type = 'sine';
        harm2.frequency.value = freq * 2;

        const harm3 = ctx.createOscillator();
        harm3.type = 'sine';
        harm3.frequency.value = freq * 3;

        const harm5 = ctx.createOscillator(); // 5th harmonic for nasality
        harm5.type = 'sine';
        harm5.frequency.value = freq * 5;

        lfoGain.connect(harm1.detune);
        lfoGain.connect(harm2.detune);
        lfoGain.connect(harm3.detune);
        lfoGain.connect(harm5.detune);

        // Quick attack - harmonium responds immediately
        const gain1 = ctx.createGain();
        gain1.gain.setValueAtTime(0.001, ctx.currentTime);
        gain1.gain.exponentialRampToValueAtTime(volume * 0.65 * gainReduction, ctx.currentTime + 0.5);

        const gain2 = ctx.createGain();
        gain2.gain.setValueAtTime(0.001, ctx.currentTime);
        gain2.gain.exponentialRampToValueAtTime(volume * 0.45 * gainReduction, ctx.currentTime + 0.5);

        const gain3 = ctx.createGain();
        gain3.gain.setValueAtTime(0.001, ctx.currentTime);
        gain3.gain.exponentialRampToValueAtTime(volume * 0.35 * gainReduction, ctx.currentTime + 0.5);

        const gain4 = ctx.createGain();
        gain4.gain.setValueAtTime(0.001, ctx.currentTime);
        gain4.gain.exponentialRampToValueAtTime(volume * 0.25 * gainReduction, ctx.currentTime + 0.5);

        harm1.connect(gain1);
        harm2.connect(gain2);
        harm3.connect(gain3);
        harm5.connect(gain4);

        nodes.push(harm1, harm2, harm3, harm5, gain1, gain2, gain3, gain4);
        gainNodes.push(gain1, gain2, gain3, gain4);
      });

      // Bandpass for nasal character
      const filter = ctx.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.value = 1600;
      filter.Q.value = 3;

      const mixGain = ctx.createGain();

      // Post-filter gain to compensate for bandpass loss
      const outputGain = ctx.createGain();
      outputGain.gain.value = 2.2; // Bandpass filters cut a lot of volume

      gainNodes.forEach(gn => gn.connect(mixGain));
      mixGain.connect(filter);
      filter.connect(outputGain);
      outputGain.connect(compressor);

      lfo.start();
      nodes.forEach(node => { if (node.start) node.start(); });

      return {
        nodes: [...nodes, filter, mixGain, outputGain, lfo, lfoGain],
        gainNodes: gainNodes,
        gainRamps: [0.65, 0.45, 0.35, 0.25]
      };
    }

    function createPumpOrganTheater(ctx, notes, volume) {
      // Theater organ: Dramatic vibrato, bright tone, percussive attack
      const nodes = [];
      const gainNodes = [];
      const gainReduction = Math.max(0.5, 1 / Math.sqrt(notes.size));

      // Dramatic vibrato
      const vibrato = ctx.createOscillator();
      vibrato.frequency.value = 6; // Faster, more dramatic
      vibrato.type = 'sine';

      const vibratoGain = ctx.createGain();
      vibratoGain.gain.value = 12; // Deep vibrato
      vibrato.connect(vibratoGain);

      notes.forEach(note => {
        const freq = noteFreqs[note];
        if (!freq) return;

        // Bright harmonic series
        const osc1 = ctx.createOscillator();
        osc1.type = 'sine';
        osc1.frequency.value = freq;

        const osc2 = ctx.createOscillator();
        osc2.type = 'sine';
        osc2.frequency.value = freq * 2;

        const osc3 = ctx.createOscillator();
        osc3.type = 'sine';
        osc3.frequency.value = freq * 4; // Higher harmonics for brightness

        const osc4 = ctx.createOscillator();
        osc4.type = 'sine';
        osc4.frequency.value = freq * 6;

        vibratoGain.connect(osc1.detune);
        vibratoGain.connect(osc2.detune);
        vibratoGain.connect(osc3.detune);
        vibratoGain.connect(osc4.detune);

        // Quick percussive attack
        const gain1 = ctx.createGain();
        gain1.gain.setValueAtTime(0.001, ctx.currentTime);
        gain1.gain.exponentialRampToValueAtTime(volume * 0.65 * gainReduction, ctx.currentTime + 0.3);

        const gain2 = ctx.createGain();
        gain2.gain.setValueAtTime(0.001, ctx.currentTime);
        gain2.gain.exponentialRampToValueAtTime(volume * 0.45 * gainReduction, ctx.currentTime + 0.3);

        const gain3 = ctx.createGain();
        gain3.gain.setValueAtTime(0.001, ctx.currentTime);
        gain3.gain.exponentialRampToValueAtTime(volume * 0.35 * gainReduction, ctx.currentTime + 0.3);

        const gain4 = ctx.createGain();
        gain4.gain.setValueAtTime(0.001, ctx.currentTime);
        gain4.gain.exponentialRampToValueAtTime(volume * 0.2 * gainReduction, ctx.currentTime + 0.3);

        osc1.connect(gain1);
        osc2.connect(gain2);
        osc3.connect(gain3);
        osc4.connect(gain4);

        nodes.push(osc1, osc2, osc3, osc4, gain1, gain2, gain3, gain4);
        gainNodes.push(gain1, gain2, gain3, gain4);
      });

      // Bright filter
      const filter = ctx.createBiquadFilter();
      filter.type = 'lowpass';
      filter.frequency.value = 3500;
      filter.Q.value = 1;

      const mixGain = ctx.createGain();

      // Post-filter gain to match default volume
      const outputGain = ctx.createGain();
      outputGain.gain.value = 1.1; // Minimal boost for bright sound

      gainNodes.forEach(gn => gn.connect(mixGain));
      mixGain.connect(filter);
      filter.connect(outputGain);
      outputGain.connect(compressor);

      vibrato.start();
      nodes.forEach(node => { if (node.start) node.start(); });

      return {
        nodes: [...nodes, filter, mixGain, outputGain, vibrato, vibratoGain],
        gainNodes: gainNodes,
        gainRamps: [0.65, 0.45, 0.35, 0.2]
      };
    }

    function startDrone() {
      const ctx = audioCtx;
      stopDrone();
      if (droneNotes.size === 0) return;

      switch (droneSound) {
        case 'pump_organ_classic':
          activeDrone = createPumpOrganClassic(ctx, droneNotes, droneGain);
          break;
        case 'pump_organ_wheezy':
          activeDrone = createPumpOrganWheezy(ctx, droneNotes, droneGain);
          break;
        case 'pump_organ_church':
          activeDrone = createPumpOrganChurch(ctx, droneNotes, droneGain);
          break;
        case 'pump_organ_celeste':
          activeDrone = createPumpOrganCeleste(ctx, droneNotes, droneGain);
          break;
        case 'pump_organ_vox':
          activeDrone = createPumpOrganVox(ctx, droneNotes, droneGain);
          break;
        case 'pump_organ_harmonium':
          activeDrone = createPumpOrganHarmonium(ctx, droneNotes, droneGain);
          break;
        case 'pump_organ_theater':
          activeDrone = createPumpOrganTheater(ctx, droneNotes, droneGain);
          break;
        case 'air_organ':
          activeDrone = createAirOrganDrone(ctx, droneNotes, droneGain);
          break;
        case 'warm_pad':
          activeDrone = createWarmPadDrone(ctx, droneNotes, droneGain);
          break;
        case 'distorted':
          activeDrone = createDistortedDrone(ctx, droneNotes, droneGain);
          break;
        default:
          activeDrone = createDefaultDrone(ctx, droneNotes, droneGain);
      }
    }
    
    function stopDrone() {
      if (activeDrone && activeDrone.nodes) {
        activeDrone.nodes.forEach(node => {
          try {
            if (node.stop) node.stop();
            node.disconnect();
          } catch(e) {
            if (console) console.warn('Error stopping drone node:', e);
          }
        });
        activeDrone.gainNodes = [];
        activeDrone.gainRamps = [];
      }
      activeDrone = null;
    }
    
    function updateDroneVolume() {
      if (activeDrone && activeDrone.gainNodes && audioCtx) {
        const ctx = audioCtx;
        const gainReduction = Math.max(0.5, 1 / Math.sqrt(droneNotes.size));

        let rampIndex = 0;
        activeDrone.gainNodes.forEach(gainNode => {
          // Use the stored ramp values to maintain the sound's character.
          // The modulo operator cycles through the ramp values for sounds with
          // multiple oscillators per note (like the default drone).
          const rampValue = activeDrone.gainRamps[rampIndex % activeDrone.gainRamps.length];
          const targetGain = droneGain * rampValue * gainReduction;

          // Smoothly ramp to the new volume to avoid clicks
          gainNode.gain.cancelScheduledValues(ctx.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(targetGain, ctx.currentTime + 0.2);

          rampIndex++;
        });
      }
    }

    // Piano Keyboard Functions
    function buildPianoKeyboard() {
      const keyboard = $('pianoKeyboard');
      keyboard.innerHTML = '';

      // Render white keys first, then black keys on top
      pianoLayout.forEach(key => {
        if (key.type === 'white') {
          const keyEl = document.createElement('div');
          keyEl.className = 'piano-key white';
          keyEl.dataset.note = key.note;

          // Add note label (highlight middle C with star)
          const label = document.createElement('span');
          label.className = 'piano-label';
          if (key.note === 'C3') {
            label.textContent = 'C3 ★';
            label.setAttribute('title', 'Middle C');
          } else {
            label.textContent = key.note;
          }
          keyEl.appendChild(label);

          // Check if this note is active
          if (droneNotes.has(key.note)) {
            keyEl.classList.add('active');
          }

          // Click handler
          keyEl.addEventListener('click', () => handlePianoKeyClick(key.note));

          keyboard.appendChild(keyEl);
        }
      });

      // Render black keys with absolute positioning
      pianoLayout.forEach(key => {
        if (key.type === 'black') {
          const keyEl = document.createElement('div');
          keyEl.className = 'piano-key black';
          keyEl.dataset.note = key.note;
          keyEl.style.left = `${key.pos * 28 - 9}px`; // 28px per white key, -9px to center

          // Add note label (hidden by CSS but kept for accessibility)
          const label = document.createElement('span');
          label.className = 'piano-label';
          label.textContent = key.note;
          keyEl.appendChild(label);

          // Check if this note is active
          if (droneNotes.has(key.note)) {
            keyEl.classList.add('active');
          }

          // Click handler
          keyEl.addEventListener('click', () => handlePianoKeyClick(key.note));

          keyboard.appendChild(keyEl);
        }
      });

      updatePianoDisplay();
    }

    function handlePianoKeyClick(note) {
      // Toggle note in the set
      if (droneNotes.has(note)) {
        droneNotes.delete(note);
      } else {
        droneNotes.add(note);
      }

      // Update UI
      updatePianoDisplay();

      // Restart drone if playing
      if (isPlaying) {
        stopDrone();
        startDrone();
      }
    }

    function updatePianoDisplay() {
      // Update visual key states
      document.querySelectorAll('.piano-key').forEach(keyEl => {
        const note = keyEl.dataset.note;
        keyEl.classList.toggle('active', droneNotes.has(note));
      });

      // Update active notes display
      const activeNotesDisplay = $('pianoActiveNotes');
      if (droneNotes.size === 0) {
        activeNotesDisplay.textContent = 'No notes selected';
        activeNotesDisplay.style.color = 'var(--text-muted)';
      } else {
        const notesArray = Array.from(droneNotes).sort((a, b) => {
          const aIndex = pianoLayout.findIndex(k => k.note === a);
          const bIndex = pianoLayout.findIndex(k => k.note === b);
          return aIndex - bIndex;
        });
        activeNotesDisplay.textContent = notesArray.join(' + ');
        activeNotesDisplay.style.color = 'var(--text)';
      }

      // Update main drone control display
      if (droneNotes.size > 0) {
        const firstNote = Array.from(droneNotes)[0];
        droneValue.textContent = droneNotes.size === 1 ? firstNote : `${firstNote} +${droneNotes.size - 1}`;
      } else {
        droneValue.textContent = '—';
      }
    }

    // Visualization State
    const vizState = {
      beatCircle: true,
      pulse: true
    };

    // Initialize Beat Circle Visualization
    function initBeatCircle() {
      const svg = $('beatCircle');
      const centerX = 100;
      const centerY = 100;
      const radius = 85;
      const segments = 8;

      // Create segments
      for (let i = 0; i < segments; i++) {
        const startAngle = (i / segments) * 360 - 90; // Start from top
        const endAngle = ((i + 1) / segments) * 360 - 90;
        const path = createSegmentPath(centerX, centerY, radius, startAngle, endAngle);

        const segmentEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        segmentEl.setAttribute('d', path);
        segmentEl.setAttribute('class', 'beat-segment' + (i === 0 ? ' beat-one' : ''));
        segmentEl.dataset.step = i;
        svg.appendChild(segmentEl);
      }

      // Create center text
      const centerText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      centerText.setAttribute('x', centerX);
      centerText.setAttribute('y', centerY);
      centerText.setAttribute('class', 'beat-center-text');
      centerText.setAttribute('id', 'beatCenterText');
      centerText.textContent = '1';
      svg.appendChild(centerText);

      // Create playhead (rotating line from center)
      const playhead = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      playhead.setAttribute('x1', centerX);
      playhead.setAttribute('y1', centerY);
      playhead.setAttribute('x2', centerX);
      playhead.setAttribute('y2', centerY - radius + 10);
      playhead.setAttribute('class', 'beat-playhead');
      playhead.setAttribute('id', 'beatPlayhead');
      svg.appendChild(playhead);
    }

    // Create SVG arc path
    function createSegmentPath(cx, cy, r, startAngle, endAngle) {
      const innerRadius = r * 0.4;
      const start = polarToCartesian(cx, cy, r, endAngle);
      const end = polarToCartesian(cx, cy, r, startAngle);
      const innerStart = polarToCartesian(cx, cy, innerRadius, endAngle);
      const innerEnd = polarToCartesian(cx, cy, innerRadius, startAngle);
      const largeArcFlag = endAngle - startAngle <= 180 ? '0' : '1';

      return [
        'M', start.x, start.y,
        'A', r, r, 0, largeArcFlag, 0, end.x, end.y,
        'L', innerEnd.x, innerEnd.y,
        'A', innerRadius, innerRadius, 0, largeArcFlag, 1, innerStart.x, innerStart.y,
        'Z'
      ].join(' ');
    }

    function polarToCartesian(cx, cy, r, angleDegrees) {
      const angleRadians = (angleDegrees * Math.PI) / 180;
      return {
        x: cx + r * Math.cos(angleRadians),
        y: cy + r * Math.sin(angleRadians)
      };
    }

    // Update Beat Circle Visualization
    function updateBeatCircle(step) {
      if (!vizState.beatCircle) return;

      // Update segments
      const segments = document.querySelectorAll('.beat-segment');
      segments.forEach((seg, i) => {
        seg.classList.toggle('active', i === step);
      });

      // Update center text
      const centerText = $('beatCenterText');
      if (centerText) {
        centerText.textContent = step + 1;
        centerText.classList.toggle('active', true);
        setTimeout(() => centerText.classList.toggle('active', false), 100);
      }

      // Update playhead rotation
      const playhead = $('beatPlayhead');
      if (playhead) {
        const rotation = (step / STEPS) * 360;
        playhead.style.transform = `rotate(${rotation}deg)`;
      }

      // Flash on beat 1
      if (step === 0) {
        const container = $('beatCircleContainer');
        if (container) {
          container.classList.add('flash');
          setTimeout(() => container.classList.remove('flash'), 120);
        }
      }
    }

    // Trigger Visual Pulse
    function triggerVisualPulse(step) {
      if (!vizState.pulse) return;

      // Background pulse
      if (step === 0) {
        document.body.classList.add('beat-one-pulse');
        setTimeout(() => document.body.classList.remove('beat-one-pulse'), 180);
      } else {
        document.body.classList.add('beat-pulse');
        setTimeout(() => document.body.classList.remove('beat-pulse'), 120);
      }

      // Drum color flashes
      const sequencer = document.querySelector('.sequencer');
      if (sequencer) {
        if (patterns.kick && patterns.kick[step]) {
          sequencer.classList.add('kick-hit');
          setTimeout(() => sequencer.classList.remove('kick-hit'), 150);
        }
        if (patterns.snare && patterns.snare[step]) {
          sequencer.classList.add('snare-hit');
          setTimeout(() => sequencer.classList.remove('snare-hit'), 150);
        }
        if (patterns.hihat && patterns.hihat[step]) {
          sequencer.classList.add('hihat-hit');
          setTimeout(() => sequencer.classList.remove('hihat-hit'), 150);
        }
      }
    }

    // Update Step Numbers with Enhanced Highlighting
    function updateStepNumbers(step) {
      const stepNumbers = document.querySelectorAll('.step-number');
      stepNumbers.forEach((num, i) => {
        num.classList.toggle('active', i === step);
      });
    }

    // Initialize Visualization Controls
    function initVisualizationControls() {
      // Beat Circle toggle
      const beatCircleToggle = $('vizBeatCircle');
      if (beatCircleToggle) {
        beatCircleToggle.addEventListener('change', e => {
          vizState.beatCircle = e.target.checked;
          const container = $('beatCircleContainer');
          if (container) {
            container.style.display = e.target.checked ? 'flex' : 'none';
          }
          // Save preference
          localStorage.setItem('beatbox-viz-beat-circle', e.target.checked);
        });

        // Load saved preference
        const saved = localStorage.getItem('beatbox-viz-beat-circle');
        if (saved !== null) {
          vizState.beatCircle = saved === 'true';
          beatCircleToggle.checked = vizState.beatCircle;
          const container = $('beatCircleContainer');
          if (container) {
            container.style.display = vizState.beatCircle ? 'flex' : 'none';
          }
        }
      }

      // Ambient Pulse toggle
      const pulseToggle = $('vizPulse');
      if (pulseToggle) {
        pulseToggle.addEventListener('change', e => {
          vizState.pulse = e.target.checked;
          // Save preference
          localStorage.setItem('beatbox-viz-pulse', e.target.checked);
        });

        // Load saved preference
        const saved = localStorage.getItem('beatbox-viz-pulse');
        if (saved !== null) {
          vizState.pulse = saved === 'true';
          pulseToggle.checked = vizState.pulse;
        }
      }
    }

    // Mobile-Optimized Scheduler
    function scheduler() {
      const ctx = audioCtx;
      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      const lookaheadTime = isMobile ? 0.08 : 0.1;
      const scheduleAheadTime = isMobile ? 0.08 : 0.1;

      while (nextNoteTime < ctx.currentTime + scheduleAheadTime) {
        // Schedule drums
        if (patterns.kick[currentStep]) playKick(nextNoteTime);
        if (patterns.snare[currentStep]) playSnare(nextNoteTime);
        if (patterns.hihat[currentStep]) playHiHat(nextNoteTime);

        // Update UI
        updateStepUI(currentStep);

        // Update visualizations
        updateBeatCircle(currentStep);
        updateStepNumbers(currentStep);
        triggerVisualPulse(currentStep);

        // Haptic feedback on downbeat
        if (currentStep === 0 && navigator.vibrate) {
          const timeUntil = nextNoteTime - ctx.currentTime;
          setTimeout(() => navigator.vibrate(10), Math.max(0, timeUntil * 1000));
        }

        // Advance
        currentStep = (currentStep + 1) % STEPS;
        nextNoteTime += 60 / bpm / 2; // 8th notes
      }
    }
    
    function updateStepUI(step) {
      // Clear previous playing states
      document.querySelectorAll('.step.playing').forEach(el => {
        el.classList.remove('playing');
      });
      
      // Add playing state to current step
      ['kick', 'snare', 'hihat'].forEach(track => {
        const steps = document.querySelectorAll(`#${track}-steps .step`);
        if (steps[step]) {
          steps[step].classList.add('playing');
        }
      });
    }
    
    // Start/Stop
    function start() {
      unlockAudio();
      initAudio();
      
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
      
      isPlaying = true;
      currentStep = 0;
      nextNoteTime = audioCtx.currentTime;
      
      playBtn.classList.add('playing');
      status.classList.add('playing');
      status.textContent = 'PLAYING';
      
      startDrone();
      // Optimized scheduler interval for mobile performance
      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      const interval = isMobile ? 20 : 25;
      schedulerTimer = setInterval(scheduler, interval);
    }
    
    function stop() {
      isPlaying = false;
      clearInterval(schedulerTimer);
      schedulerTimer = null;
      
      playBtn.classList.remove('playing');
      status.classList.remove('playing');
      status.textContent = 'STOPPED';
      
      stopDrone();
      
      // Clear playing states
      document.querySelectorAll('.step.playing').forEach(el => {
        el.classList.remove('playing');
      });
    }
    
    // Pattern Management
    function updatePatternUI() {
      ['kick', 'snare', 'hihat'].forEach(track => {
        const steps = document.querySelectorAll(`#${track}-steps .step`);
        patterns[track].forEach((active, i) => {
          if (steps[i]) {
            steps[i].classList.toggle('active', active);
          }
        });
      });
    }
    
    function encodePattern() {
      return btoa(JSON.stringify(patterns));
    }
    
    function decodePattern(str) {
      try {
        return JSON.parse(atob(str));
      } catch(e) {
        return null;
      }
    }
    
    /*
      VERTICAL VOLUME SLIDER IMPLEMENTATION
      
      Custom vertical slider controls for precise audio level adjustment.
      
      Design rationale:
      - Vertical orientation mimics professional mixing consoles
      - Positioned as "bookends" flanking the tempo display
      - Maintains minimal aesthetic while providing easy access
      
      Technical implementation:
      - Inverted Y-coordinate calculation (bottom = 100%, top = 0%)
      - Global event listeners for smooth dragging beyond slider bounds
      - Separate touch event handling for mobile compatibility
      - Real-time audio parameter updates via onChange callbacks
      
      UX considerations:
      - Click anywhere on track to jump to that level
      - Drag for smooth continuous adjustment
      - Visual feedback via fill gradient and thumb expansion
      - Percentage values displayed above for precise control
      
      Cross-platform compatibility:
      - Mouse events for desktop
      - Touch events for mobile/tablet
      - Unified coordinate calculation for both input types
    */
    function initVolumeSlider(id, initialValue, onChange) {
      const track = $(id + 'Track');
      const fill = $(id + 'Fill');
      const thumb = $(id + 'Thumb');
      const valueDisplay = $(id + 'Value');
      
      let isDragging = false;
      
      function updateSlider(e) {
        const rect = track.getBoundingClientRect();
        // Invert Y coordinate: bottom of track = 100%, top = 0%
        const percent = Math.max(0, Math.min(100, 
          Math.round((1 - (e.clientY - rect.top) / rect.height) * 100)
        ));
        
        // Update visual elements
        fill.style.height = percent + '%';
        thumb.style.bottom = percent + '%';
        valueDisplay.textContent = percent + '%';
        
        // Trigger audio parameter update
        if (onChange) onChange(percent);
      }
      
      // Desktop mouse interaction
      track.addEventListener('mousedown', e => {
        isDragging = true;
        updateSlider(e);
      });
      
      // Global listeners for smooth dragging
      document.addEventListener('mousemove', e => {
        if (isDragging) updateSlider(e);
      });
      
      document.addEventListener('mouseup', () => {
        isDragging = false;
      });
      
      // Mobile touch interaction
      track.addEventListener('touchstart', e => {
        isDragging = true;
        const touch = e.touches[0];
        updateSlider(touch);
      });
      
      document.addEventListener('touchmove', e => {
        if (isDragging) {
          const touch = e.touches[0];
          updateSlider(touch);
        }
      });
      
      document.addEventListener('touchend', () => {
        isDragging = false;
      });
    }
    
    // Step Count Management
    function setStepCount(newSteps) {
      const oldSteps = STEPS;
      STEPS = newSteps;
      
      // Resize patterns
      ['kick', 'snare', 'hihat'].forEach(track => {
        if (newSteps < oldSteps) {
          patterns[track] = patterns[track].slice(0, newSteps);
        } else {
          while (patterns[track].length < newSteps) {
            patterns[track].push(false);
          }
        }
      });
      
      rebuildSequencer();
      updatePatternUI();
    }
    
    function rebuildSequencer() {
      // Update step numbers grid
      const stepNumbers = $('stepNumbers');
      stepNumbers.innerHTML = '';
      for (let i = 0; i < STEPS; i++) {
        const number = document.createElement('div');
        number.className = 'step-number' + (i === 0 ? ' beat-one' : '');
        number.textContent = i + 1;
        stepNumbers.appendChild(number);
      }
      
      // Update CSS grid columns for sequencer
      const stepContainers = document.querySelectorAll('.steps, .numbers-grid');
      stepContainers.forEach(container => {
        container.style.gridTemplateColumns = `repeat(${STEPS}, 1fr)`;
      });
      
      // Rebuild step buttons
      ['kick', 'snare', 'hihat'].forEach(track => {
        const container = $(`${track}-steps`);
        container.innerHTML = '';
        
        for (let i = 0; i < STEPS; i++) {
          const step = document.createElement('button');
          step.className = 'step';
          step.dataset.track = track;
          step.dataset.step = i;
          
          // Enhanced mobile interaction with gestures
          let swipeStart = null;
          let longPressTimer = null;
          
          const handleStepClick = (e) => {
            const t = e.currentTarget.dataset.track;
            const s = parseInt(e.currentTarget.dataset.step);
            patterns[t][s] = !patterns[t][s];
            e.currentTarget.classList.toggle('active');
            
            // Haptic feedback on mobile
            if (navigator.vibrate) navigator.vibrate(15);
          };
          
          // Desktop click
          step.addEventListener('click', handleStepClick);
          
          // Mobile touch with gesture support
          step.addEventListener('touchstart', e => {
            e.preventDefault();
            const touch = e.touches[0];
            swipeStart = { x: touch.clientX, y: touch.clientY, time: performance.now() };
            
            // Long press for pattern copy (experimental)
            longPressTimer = setTimeout(() => {
              const trackPattern = patterns[track].map(x => x ? '1' : '0').join('');
              
              // Visual feedback for copy
              step.style.boxShadow = '0 0 20px #f59e0b';
              setTimeout(() => step.style.boxShadow = '', 300);
              
              // Strong haptic feedback
              if (navigator.vibrate) navigator.vibrate([50, 50, 50]);
              
              longPressTimer = null;
            }, 800);
            
          }, { passive: false });
          
          step.addEventListener('touchmove', e => {
            if (!swipeStart) return;
            
            const touch = e.touches[0];
            const deltaX = touch.clientX - swipeStart.x;
            const deltaY = touch.clientY - swipeStart.y;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            // Clear long press if moved too much
            if (distance > 10 && longPressTimer) {
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }
            
            // Horizontal swipe to clear step (experimental)
            if (Math.abs(deltaX) > 40 && Math.abs(deltaY) < 20) {
              if (patterns[track][i]) {
                patterns[track][i] = false;
                step.classList.remove('active');
                if (navigator.vibrate) navigator.vibrate(30);
              }
              swipeStart = null;
            }
          }, { passive: false });
          
          step.addEventListener('touchend', e => {
            e.preventDefault();
            
            if (longPressTimer) {
              clearTimeout(longPressTimer);
              longPressTimer = null;
            }
            
            if (swipeStart) {
              const timeDiff = performance.now() - swipeStart.time;
              // Normal tap if short duration and minimal movement
              if (timeDiff < 200) {
                handleStepClick(e);
              }
            }
            
            swipeStart = null;
          }, { passive: false });
          
          container.appendChild(step);
        }
      });
    }
    
    // Initialize UI
    function initUI() {
      // Navigation tabs
      document.querySelectorAll('.nav-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          const viewId = tab.dataset.view;

          // Update tabs
          document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');

          // Update views
          document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
          document.getElementById(viewId + '-view').classList.add('active');
        });
      });

      // Initial sequencer build
      rebuildSequencer();
      
      // Initialize volume sliders
      initVolumeSlider('droneVolume', 60, value => {
        droneGain = value / 100;
        droneVolValue.textContent = value + '%';
        droneVolSliderValue.textContent = value + '%';
        updateDroneVolume();
      });
      
      initVolumeSlider('drumVolume', 70, value => {
        drumGain = value / 100;
        drumVolValue.textContent = value + '%';
        drumVolSliderValue.textContent = value + '%';
      });
      
      // Step buttons are now created in rebuildSequencer()
      
      // Play button
      playBtn.addEventListener('click', () => {
        if (isPlaying) stop();
        else start();
      });
      
      // Tempo control (both slider and display click)
      tempoSlider.addEventListener('input', e => {
        bpm = parseInt(e.target.value);
        tempoValue.textContent = bpm;
        tempoSliderValue.textContent = `${bpm} BPM`;
      });
      
      tempoValue.addEventListener('click', () => {
        advancedContent.classList.add('show');
        advancedToggle.classList.add('open');
        tempoSlider.focus();
      });

      // Piano keyboard controls
      buildPianoKeyboard();

      $('droneControl').addEventListener('click', () => {
        advancedContent.classList.add('show');
        advancedToggle.classList.add('open');
      });

      // Clear all piano notes
      $('pianoClear').addEventListener('click', () => {
        droneNotes.clear();
        updatePianoDisplay();
        if (isPlaying) {
          stopDrone();
        }
      });

      // Drone sound selection
      $('droneSoundSelect').addEventListener('change', e => {
          droneSound = e.target.value;
          if (isPlaying) {
              stopDrone();
              startDrone();
          }
      });
      
      // Volume controls
      droneVolSlider.addEventListener('input', e => {
        droneGain = parseInt(e.target.value) / 100;
        droneVolValue.textContent = `${e.target.value}%`;
        droneVolSliderValue.textContent = `${e.target.value}%`;
        updateDroneVolume();
      });
      
      $('droneVolControl').addEventListener('click', () => {
        advancedContent.classList.add('show');
        advancedToggle.classList.add('open');
        droneVolSlider.focus();
      });
      
      drumVolSlider.addEventListener('input', e => {
        drumGain = parseInt(e.target.value) / 100;
        drumVolValue.textContent = `${e.target.value}%`;
        drumVolSliderValue.textContent = `${e.target.value}%`;
      });
      
      $('drumVolControl').addEventListener('click', () => {
        advancedContent.classList.add('show');
        advancedToggle.classList.add('open');
        drumVolSlider.focus();
      });

      // Advanced toggle
      advancedToggle.addEventListener('click', () => {
        advancedContent.classList.toggle('show');
        advancedToggle.classList.toggle('open');
      });
      
      // Track mute/solo (clicking labels)
      document.querySelectorAll('.track-label').forEach(label => {
        label.addEventListener('click', e => {
          const track = e.target.dataset.track;
          muted[track] = !muted[track];
          e.target.classList.toggle('muted');
        });
      });
      
      // Adaptive preset patterns
      $('preset1').addEventListener('click', () => {
        if (STEPS === 4) {
          patterns.kick =  [true,false,true,false];
          patterns.snare = [false,true,false,true];
          patterns.hihat = [true,false,true,false];
        } else {
          patterns.kick =  [true,false,false,false,true,false,false,false];
          patterns.snare = [false,false,true,false,false,false,true,false];
          patterns.hihat = [true,true,false,true,true,true,false,true];
        }
        updatePatternUI();
      });
      
      $('preset2').addEventListener('click', () => {
        if (STEPS === 4) {
          patterns.kick =  [true,false,false,true];
          patterns.snare = [false,false,true,false];
          patterns.hihat = [true,true,true,true];
        } else {
          patterns.kick =  [true,false,true,false,false,false,true,false];
          patterns.snare = [false,true,false,true,false,true,false,true];
          patterns.hihat = [true,false,true,false,true,false,true,false];
        }
        updatePatternUI();
      });
      
      $('preset3').addEventListener('click', () => {
        if (STEPS === 4) {
          patterns.kick =  [true,true,false,false];
          patterns.snare = [false,false,false,true];
          patterns.hihat = [false,true,false,true];
        } else {
          patterns.kick =  [true,false,false,true,false,false,true,false];
          patterns.snare = [false,false,false,false,true,false,false,false];
          patterns.hihat = [true,true,true,true,true,true,true,true];
        }
        updatePatternUI();
      });
      
      // Step count toggle (replaces clear button)
      $('stepToggle').addEventListener('click', () => {
        const newSteps = STEPS === 8 ? 4 : 8;
        setStepCount(newSteps);
        $('stepToggle').textContent = `${STEPS === 4 ? '8' : '4'}/${STEPS} STEPS`;
      });
      
      /*
        TAP TEMPO IMPLEMENTATION
        
        Enhanced tap tempo system using median-based calculation for stability.
        
        Key features:
        - Uses performance.now() for high-precision timing
        - 4-second window for tap collection (prevents stale taps)
        - Median calculation instead of average (more stable against erratic taps)
        - Extended BPM range (60-200) for various musical styles
        - Immediate response after 2 taps (faster than traditional 4-tap systems)
        - Visual feedback with scale animation on successful detection
        
        Why median over average:
        - Average is sensitive to outliers (one bad tap ruins the calculation)
        - Median finds the "middle" interval, ignoring extreme values
        - More stable and predictable tempo detection
        
        Performance timing rationale:
        - Date.now() has ~15ms resolution on some browsers
        - performance.now() provides microsecond precision
        - Critical for accurate rhythm detection
      */
      let tapTimes = [];
      const handleTapTempo = () => {
        const now = performance.now();
        const cutoff = now - 4000; // 4 second rolling window
        
        // Remove stale taps beyond the time window
        tapTimes = tapTimes.filter(t => t > cutoff);
        tapTimes.push(now);
        
        if (tapTimes.length >= 2) {
          const intervals = [];
          for (let i = 1; i < tapTimes.length; i++) {
            intervals.push(tapTimes[i] - tapTimes[i-1]);
          }
          
          // Median calculation for stability
          intervals.sort((a, b) => a - b);
          const median = intervals[Math.floor(intervals.length / 2)];
          const newBpm = Math.round(60000 / median);
          
          if (newBpm >= 60 && newBpm <= 200) {
            bpm = newBpm;
            tempoSlider.value = bpm;
            tempoValue.textContent = bpm;
            tempoSliderValue.textContent = `${bpm} BPM`;
            
            // Visual feedback confirms successful tempo detection
            tempoDisplay.style.transform = 'scale(0.95)';
            setTimeout(() => {
              tempoDisplay.style.transform = 'scale(1)';
            }, 100);
          }
        }
      };
      
      // Add tap tempo to button and display
      $('tapTempo').addEventListener('click', handleTapTempo);
      
      /*
        TEMPO DISPLAY CLICK HANDLING
        
        Robust event handling to prevent browser interference with tap tempo.
        
        Complex event prevention required because:
        - Some browsers auto-scroll on rapid clicks (accessibility feature)
        - Touch events can trigger both touch and click handlers
        - Default link/button behaviors can interfere with timing
        - Page focus changes can disrupt the tempo detection
        
        Solutions implemented:
        - preventDefault() stops default browser behaviors
        - stopPropagation() prevents event bubbling to parent elements
        - window.scrollTo() locks scroll position during interaction
        - passive: false ensures preventDefault() is allowed to work
        - Separate touch/click handlers for cross-platform compatibility
        
        This ensures clean, predictable tempo detection without UI interference.
      */
      const tempoDisplay = $('tempoDisplay');
      
      const handleTempoClick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        // Lock scroll position to prevent page jumping
        window.scrollTo(0, window.pageYOffset);
        
        handleTapTempo();
        return false;
      };
      
      // Desktop and mobile event handling
      tempoDisplay.addEventListener('click', handleTempoClick, { passive: false });
      tempoDisplay.addEventListener('touchend', e => {
        e.preventDefault();
        e.stopPropagation();
        handleTapTempo();
      }, { passive: false });

      // Keyboard shortcuts
      document.addEventListener('keydown', e => {
        if (e.code === 'Space' && e.target === document.body) {
          e.preventDefault();
          if (isPlaying) stop();
          else start();
        }
        
        // Number keys for patterns
        if (e.code >= 'Digit1' && e.code <= 'Digit8') {
          const step = parseInt(e.code.slice(-1)) - 1;
          const track = e.shiftKey ? 'snare' : e.altKey ? 'hihat' : 'kick';
          patterns[track][step] = !patterns[track][step];
          updatePatternUI();
        }
        
        // Arrow keys for tempo
        if (e.code === 'ArrowUp') {
          bpm = Math.min(180, bpm + 1);
          tempoValue.textContent = bpm;
          tempoSlider.value = bpm;
          tempoSliderValue.textContent = `${bpm} BPM`;
        }
        if (e.code === 'ArrowDown') {
          bpm = Math.max(60, bpm - 1);
          tempoValue.textContent = bpm;
          tempoSlider.value = bpm;
          tempoSliderValue.textContent = `${bpm} BPM`;
        }
        
        // Clear all patterns (C key)
        if (e.code === 'KeyC' && e.target === document.body) {
          Object.keys(patterns).forEach(track => {
            for (let i = 0; i < patterns[track].length; i++) {
              patterns[track][i] = false;
            }
          });
          updatePatternUI();
        }
        
        // Toggle step count (T key)
        if (e.code === 'KeyT' && e.target === document.body) {
          const newSteps = STEPS === 8 ? 4 : 8;
          setStepCount(newSteps);
          $('stepToggle').textContent = `${STEPS === 4 ? '8' : '4'}/${STEPS} STEPS`;
        }
      });

      // Initialize visualizations
      initBeatCircle();
      initVisualizationControls();
    }
    
    // Removed loadFromURL - no longer needed without save/load/share features
    
    // Mobile Performance Monitoring
    const perfMonitor = {
      frameDrops: 0,
      audioGlitches: 0,
      memoryUsage: [],
      
      startMonitoring() {
        if (typeof performance === 'undefined') return;
        
        let lastTime = performance.now();
        
        const checkFrame = () => {
          const now = performance.now();
          const delta = now - lastTime;
          
          // Frame drop detection (target: 60fps = 16.67ms)
          if (delta > 20) {
            this.frameDrops++;
          }
          
          // Memory monitoring (if available)
          if (performance.memory) {
            this.memoryUsage.push(performance.memory.usedJSHeapSize);
            // Keep only last 100 samples
            if (this.memoryUsage.length > 100) {
              this.memoryUsage.shift();
            }
          }
          
          lastTime = now;
          requestAnimationFrame(checkFrame);
        };
        
        requestAnimationFrame(checkFrame);
      },
      
      getStats() {
        const avgMemory = this.memoryUsage.length > 0 
          ? this.memoryUsage.reduce((a, b) => a + b, 0) / this.memoryUsage.length
          : 0;
          
        return {
          frameDrops: this.frameDrops,
          audioGlitches: this.audioGlitches,
          avgMemoryMB: Math.round(avgMemory / 1024 / 1024),
          isPerformanceGood: this.frameDrops < 10 && this.audioGlitches < 3
        };
      }
    };
    
    // Battery optimization for mobile
    function optimizeForBattery() {
      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      
      if (isMobile) {
        // Reduce visual updates when not playing
        const originalUpdateStepUI = updateStepUI;
        
        window.updateStepUI = function(step) {
          // Only update if playing or performance mode is on
          if (isPlaying || perfMode.checked) {
            originalUpdateStepUI(step);
          }
        };
        
        // Throttle non-critical animations
        const style = document.createElement('style');
        style.textContent = `
          @media (max-width: 768px) {
            .loading-text { animation-duration: 2s !important; }
            .status::before { animation-duration: 4s !important; }
          }
        `;
        document.head.appendChild(style);
      }
    }
    
    // Auto-detect and adjust performance settings
    function autoOptimizePerformance() {
      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      const isLowEnd = navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 2;
      
      if (isMobile || isLowEnd) {
        // Disable performance mode animations by default
        const style = document.createElement('style');
        style.textContent = `
          @media (max-width: 768px) {
            .tempo-value { animation: none !important; }
            .step.playing {
              transform: scaleY(1.05) !important;
              box-shadow: 0 0 5px rgba(45, 51, 40, 0.3) !important;
            }
          }
        `;
        document.head.appendChild(style);
        
        console.log('🔋 BeatBox Pro: Mobile optimizations enabled');
      }
    }
    
    // Pinch Gesture for Performance Mode (Experimental)
    let initialPinchDistance = null;
    
    function getDistance(touch1, touch2) {
      return Math.sqrt(
        Math.pow(touch2.clientX - touch1.clientX, 2) +
        Math.pow(touch2.clientY - touch1.clientY, 2)
      );
    }
    
    document.addEventListener('touchstart', e => {
      if (e.touches.length === 2) {
        initialPinchDistance = getDistance(e.touches[0], e.touches[1]);
      }
    }, { passive: true });
    
    document.addEventListener('touchmove', e => {
      if (e.touches.length === 2 && initialPinchDistance) {
        const currentDistance = getDistance(e.touches[0], e.touches[1]);
        const scale = currentDistance / initialPinchDistance;
        
        // Pinch out to enable performance mode
        if (scale > 1.3 && !perfMode.checked) {
          perfMode.checked = true;
          document.body.classList.add('performance');
          if (navigator.vibrate) navigator.vibrate(100);
          
          // Visual feedback
          const sequencer = document.querySelector('.sequencer');
          sequencer.style.transform = 'scale(1.05)';
          setTimeout(() => {
            sequencer.style.transform = 'scale(1)';
          }, 200);
        }
        // Pinch in to disable performance mode
        else if (scale < 0.7 && perfMode.checked) {
          perfMode.checked = false;
          document.body.classList.remove('performance');
          if (navigator.vibrate) navigator.vibrate(50);
        }
      }
    }, { passive: true });
    
    document.addEventListener('touchend', () => {
      initialPinchDistance = null;
    }, { passive: true });

    // ========== FRETBOARD LOGIC ==========

    // Music theory data
    const FB_ALL_NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const FB_C_MAJOR_SCALE = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];

    // Standard tuning: strings from high to low (e, B, G, D, A, E)
    const FB_STRING_TUNINGS = [
      { name: 'e', startNote: 'E', startOctave: 4 },
      { name: 'B', startNote: 'B', startOctave: 3 },
      { name: 'G', startNote: 'G', startOctave: 3 },
      { name: 'D', startNote: 'D', startOctave: 3 },
      { name: 'A', startNote: 'A', startOctave: 2 },
      { name: 'E', startNote: 'E', startOctave: 2 }
    ];

    // Mode interval patterns (W = whole, H = half)
    const FB_MODE_PATTERNS = {
      ionian:     ['W', 'W', 'H', 'W', 'W', 'W', 'H'],
      dorian:     ['W', 'H', 'W', 'W', 'W', 'H', 'W'],
      phrygian:   ['H', 'W', 'W', 'W', 'H', 'W', 'W'],
      lydian:     ['W', 'W', 'W', 'H', 'W', 'W', 'H'],
      mixolydian: ['W', 'W', 'H', 'W', 'W', 'H', 'W'],
      aeolian:    ['W', 'H', 'W', 'W', 'H', 'W', 'W'],
      locrian:    ['H', 'W', 'W', 'H', 'W', 'W', 'W']
    };

    // Fretboard state
    let fbCurrentMode = 'ionian';
    let fbCurrentModeRoot = 'C';
    let fbDisplayMode = 'note'; // 'note' or 'deg'

    // Get note at fret position
    function fbGetNoteAtFret(startNote, fret) {
      const startIndex = FB_ALL_NOTES.indexOf(startNote);
      const noteIndex = (startIndex + fret) % 12;
      return FB_ALL_NOTES[noteIndex];
    }

    // Check if note is in C major scale
    function fbIsInScale(note) {
      if (note.includes('#')) {
        return false;
      }
      return FB_C_MAJOR_SCALE.includes(note);
    }

    // Get scale degree relative to current mode root
    function fbGetScaleDegree(note) {
      const rootIndex = FB_C_MAJOR_SCALE.indexOf(fbCurrentModeRoot);
      const noteIndex = FB_C_MAJOR_SCALE.indexOf(note);
      if (noteIndex === -1) return null;

      let degree = noteIndex - rootIndex;
      if (degree < 0) degree += 7;
      return degree + 1;
    }

    // Get degree class name - A+B scheme
    function fbGetDegreeClass(degree) {
      if (degree === 1) return 'root';
      if (degree === 3) return 'degree-3';
      if (degree === 5) return 'degree-5';
      if (degree === 7) return 'degree-7';
      // Passing tones: 2, 4, 6
      return `degree-${degree}`;
    }

    // Get display text for note
    function fbGetNoteDisplay(note, degree) {
      if (fbDisplayMode === 'deg') {
        return degree === 1 ? 'R' : degree.toString();
      }
      return note;
    }

    // Generate fretboard HTML
    function fbGenerateFretboard() {
      const fretboard = document.getElementById('fretboard');
      if (!fretboard) return;

      const existingStrings = fretboard.querySelectorAll('.string-row, .fret-markers');
      existingStrings.forEach(el => el.remove());

      FB_STRING_TUNINGS.forEach(string => {
        const row = document.createElement('div');
        row.className = 'string-row';

        const label = document.createElement('div');
        label.className = 'string-label';
        label.textContent = string.name;
        row.appendChild(label);

        for (let fret = 0; fret <= 14; fret++) {
          const fretDiv = document.createElement('div');
          fretDiv.className = 'fret';

          const note = fbGetNoteAtFret(string.startNote, fret);

          if (fbIsInScale(note)) {
            const degree = fbGetScaleDegree(note);
            const noteDiv = document.createElement('div');
            noteDiv.className = `note ${fbGetDegreeClass(degree)}`;
            noteDiv.dataset.note = note;
            noteDiv.dataset.degree = degree;
            noteDiv.textContent = fbGetNoteDisplay(note, degree);

            noteDiv.addEventListener('click', () => {
              noteDiv.style.transform = 'scale(1.3)';
              setTimeout(() => noteDiv.style.transform = '', 150);
            });

            fretDiv.appendChild(noteDiv);
          }

          row.appendChild(fretDiv);
        }

        fretboard.appendChild(row);
      });

      // Add fret markers
      const markers = document.createElement('div');
      markers.className = 'fret-markers';

      const markerPositions = [0, 0, 0, 0, 3, 0, 5, 0, 7, 0, 9, 0, 0, 12, 0, 0];

      const emptyCell = document.createElement('div');
      emptyCell.className = 'marker-cell';
      markers.appendChild(emptyCell);

      markerPositions.forEach((pos) => {
        const cell = document.createElement('div');
        cell.className = 'marker-cell';

        if (pos === 12) {
          const inlay = document.createElement('div');
          inlay.className = 'inlay double';
          cell.appendChild(inlay);
        } else if (pos > 0) {
          const inlay = document.createElement('div');
          inlay.className = 'inlay';
          cell.appendChild(inlay);
        }

        markers.appendChild(cell);
      });

      fretboard.appendChild(markers);
    }

    // Get pattern note class for A+B scheme
    function fbGetPatternNoteClass(index) {
      if (index === 0) return 'root-note';
      if (index === 2) return 'chord-3';
      if (index === 4) return 'chord-5';
      if (index === 6) return 'chord-7';
      return 'passing';
    }

    // Update pattern display
    function fbUpdatePatternDisplay() {
      const patternDiv = document.getElementById('fb-pattern-intervals');
      const notesDiv = document.getElementById('fb-pattern-notes');
      if (!patternDiv || !notesDiv) return;

      const pattern = FB_MODE_PATTERNS[fbCurrentMode];
      patternDiv.innerHTML = pattern.map(int =>
        `<div class="interval ${int === 'W' ? 'whole' : 'half'}">${int}</div>`
      ).join('');

      const rootIndex = FB_C_MAJOR_SCALE.indexOf(fbCurrentModeRoot);
      const reorderedNotes = [];
      for (let i = 0; i < 7; i++) {
        reorderedNotes.push(FB_C_MAJOR_SCALE[(rootIndex + i) % 7]);
      }

      notesDiv.innerHTML = reorderedNotes.map((note, i) =>
        `<div class="interval ${fbGetPatternNoteClass(i)}">${note}</div>`
      ).join('');
    }

    // Update all fretboard UI elements
    function fbUpdateUI() {
      const modeBadge = document.getElementById('fb-mode-badge');
      const lcdRoot = document.getElementById('fb-lcd-root');
      const currentModeEl = document.getElementById('fb-current-mode');

      const modeName = fbCurrentMode.charAt(0).toUpperCase() + fbCurrentMode.slice(1);

      if (modeBadge) modeBadge.textContent = `${fbCurrentModeRoot} ${modeName.toUpperCase()}`;
      if (lcdRoot) lcdRoot.textContent = fbCurrentModeRoot;
      if (currentModeEl) currentModeEl.textContent = `C MAJOR / ${fbCurrentModeRoot} ${modeName.toUpperCase()}`;

      fbGenerateFretboard();
      fbUpdatePatternDisplay();
    }

    // Initialize fretboard event handlers
    function initFretboard() {
      // Mode button interaction
      document.querySelectorAll('.mode-card').forEach(card => {
        card.addEventListener('click', () => {
          document.querySelectorAll('.mode-card').forEach(c => c.classList.remove('active'));
          card.classList.add('active');

          fbCurrentMode = card.dataset.mode;
          fbCurrentModeRoot = card.dataset.root;

          fbUpdateUI();
        });
      });

      // Display toggle (NOTE / DEG)
      document.querySelectorAll('.fb-button-row .fb-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          btn.parentElement.querySelectorAll('.fb-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');

          fbDisplayMode = btn.dataset.display;
          fbGenerateFretboard();
        });
      });

      // Initial render
      fbGenerateFretboard();
      fbUpdatePatternDisplay();
    }

    // ========== END FRETBOARD LOGIC ==========

    // Initialize everything
    perfMonitor.startMonitoring();
    optimizeForBattery();
    autoOptimizePerformance();
    initUI();
    initFretboard();
    
    // Development performance logging
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
      setTimeout(() => {
        const stats = perfMonitor.getStats();
        console.log('📊 BeatBox Pro Performance Stats:', stats);
        
        if (!stats.isPerformanceGood) {
          console.warn('⚠️ Performance issues detected. Consider enabling performance optimizations.');
        }
      }, 10000); // Check after 10 seconds
    }
    
    // Remove loading screen
    setTimeout(() => {
      document.querySelector('.loading').style.display = 'none';
    }, 500);
    
    // Handle visibility change
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && isPlaying) stop();
    });
    
    // Prevent scrolling on spacebar
    window.addEventListener('keydown', e => {
      if (e.code === 'Space' && e.target === document.body) {
        e.preventDefault();
      }
    });
  })();
  </script>
</body>
</html>